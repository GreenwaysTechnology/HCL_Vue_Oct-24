				Vue.js
.....................................................................................
Pre Knowledge:

1.HTML 5
2.CSS 3
3.Javascript -ES 5 and ES 6
4.Node js fundamentals - npm

Nice to have
react or angular

Lab setup:
node.js
vs code
.....................................................................................
What is vue.js?
  Vue.js is a javascript framework for building user interfaces.

User interfae:
1.desk top app
2.web apps which is running browser
3.Mobile apps
   native
   browser based
   hybrid app

We are going to build browser based web apps.

Browser based web apps using js -  client side apps

1.JQuery
2.Angular js
3.React js
4.Angular 2.x 
5.Vue js
etc....

javascript frameworks for building server side apps -node.js 
1.express js
2.hapi js
3.Moleculer
4.Loopback
5.nest js


Vue is more popular for building browser based web applications.

Before understanding vue, we need to know the different types of web apps.

What is web and history?
 Web is distributed application, distributed means app functionality is distributed among machines and which services are accessed by network.

History:
https://home.web.cern.ch/science/computing/birth-web..

Technologies:

1.HTML 
2.HTTP protocal
3.Web server - Next Computer and Next Operating System
4.Line Mode web browser and editor



Types of Web Applications:

1.Static web apps - 1989 to 1995
   -HTML
   Web app is prepared by hand written html documents, and hosted on server.

2.Dynamic Content Generation web apps -1996 to till date

   Web app is prepared by the special program called "cgi" , hosted on server.
   -CGI - C/Perl
   -J2EE - Java,JavaServlets
   -ASP  - Vbscript,VB
   -PHP  - Php

3.Web Services - ECOMMERCE(B2 to B2) - 1998 To till date
 DATA is exchanged between two systems 
  Common data formats
   -XML - SOAP web services
   -Multi format(JSON)- RESTFull Web Services / GraphQL 

.....................................................................................
			Client Side Web App
....................................................................................

1.In 2006, w3c published new spec called "HTML 5",as part of HTML5 , W3C Published new web spec called "Single Page web App" /SPA.

 html page is prepared dynamically at client side by the browser using js, data needed for html page is accessed with help of "REST" api.


After introduction of SPA technology many frameworks and libs were created.

1.Mustache.js
2.Angular.js
3.React
4.Angular
5.Vue.js

....................................................................................
			Vue js

Vue.js is javascript client side spa framework.

.....................................................................................
			Vue as SPA framework - Client side technology
.....................................................................................

Stack:
1.html 5
2.css 3
3.js 
.....................................................................................
			   DOM Specifciation
.....................................................................................

DOM programming:

  DOM is specification for building client side web apps, DOM spec introduced by w3c 
  DOM is implemented by js and html.

What is js and why js?

  JS is programming language , created by netscap communication , to manipulate HTML
  Document at browser.
  html is generated by server and sent to client(browser), the browser just display
  html, after display generally we cant modify the html.
  Js was created to update html after display(render) - Dynamic html technology.


if you want to understand how dom works, we need to understand how html works.


HTML:
  It is also one of the programming language.


Like other languages such as c program

1.source code
  hello.c
2.compile the code
  hello.obj - compiled code
3.execute the code
  on runtime we execute the code

.....................................................................................
			How browser renders HTML
		    Internals of HTML Representation
....................................................................................

HTML is programming language -  DSL pl /declarative pl.


index.html -source code

<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>
|
-------------------Browser
loader---LOAD Code into browser
 |
   from file: or http:
 |

Parser : Parser is special compiler which converts source into lexcial tree(string tree)
 |
body
  div
     h1
        Welcome 
     h1
  div
body
|
 Complier-Compilation : Convert this into assembly
|
body -load xxx
  div
     h1
        Welcome 
     h1
  div
body
|
.....................................................................................
			Runtime  -  Allocate Memory for HTML
.....................................................................................	
HTML Execution engine : Request Os ,to allocate memory :Runtime

-LinkedList - c
body -Node
  div -Node
     h1 -Node
        Welcome -Node
     h1
  div
body

-Nodes are connected each other in hierachical structure(tree)
 
Linking the Nodes: Tree (c)

body  -Node
  |
  div -Node
    |
     h1 -Node
      |
        Welcome -Node
        |
     h1
  div
body
|
Layout/Paint Engine: will convert nodes into pxs : final output
Layout/Paint Engine: will convert nodes into pxs : final output
...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec - DOM
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be represented as Objects" : Object oriented Document Programming.

According to DOM?

Any html element is represented as "Node" inside browser engine, "Object" as inside javascript engine.

div = DIV object
.............................................................................................
				Birth of Frameworks and libs

...................................................................................
			Nets cap and HTML Tree

Netscap started a project, to access rendered tree via program, to process(add,update,delete,iterate)

Netscap initally decided to introduce java program to access the tree, but since java was not suitable, netscap decided to create java like programming language - birth of javascript.

Java script language looks the HTML tree as objects - Object oriented HTML, every html element can be thought as object. - body - body object, div element-div object

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?




............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.

.....................................................................................
			Client side web apps and vue js

Vue is client side web app framework.
but
Now a days vue can be used to build server side web apps as well

Types of SPA:

1. Pure spa
    static html + dynamic js
  Drawbacks: 
     which is not search engine ready.

2.Server side rendering - hybrid spa
   index.html is prepared at server along with search engine meta data and js files
  send to the client...
   
Full Stack:
  Building app using one single technology both front end and back end.
eg:
  Next.js
  Front End is react and back end is also react

  Nuxt.js
  Front end is vue and back end is also vue...


1.SSR :Server side Rending
   Full SSR
   Partial SSR - 
   SSR =  Server+ client => SPA(Client) + SERVER

2.SSG/Jamstack
  Static site generation.
  now a days people are building static web sites like 90's web app , in order to     improve high performance.
  Vue.js(Nuxt) can help to build SSG apps
  React.js(Next) can help to build SSG apps

You can use vue+NUXT
Based on ,use case we can pickup any one of the methods to build client side web apps, but most popular one is SPA,SSR

Vue js can be used to build any type of client side web apps(spa,ssr,ssg)
....................................................................................

Vue js Application Types:
.........................

Server side
   SSR,SSG,ISR (Full stack)

client side

1.Standalone script application-SSA
    Enchancing html (generated by server) by adding js/ js lib(jquery)

 if you have traditional web apps written using server side technology like jsp,asp.net,php which uses "js/jquery"

   Vue js is declarative replacement of imperative "jquery"

2.Web components
   Vuejs supports to create web component based architecture applications

3.SPA
   Vue is primarily popular for building spa apps
.....................................................................................
.....................................................................................
			 Getting started with Vue App
....................................................................................

What type of app we are going to build?

1.Standalone Script app
  We will see only basic level.

2.Single page web app
  We will explore very detailed

In case any app type , we need "tool" sets to create app.

There are two major tools we go with building vue.js apps

1.Without build tool
2.With build tool

1.Standalone Script app
   Without build tool.

if you plan without build tool means, you are planning to create 'standalone script'
....................................................................................
		 Project Setup-SSA(Standalone Script Application)
....................................................................................

create Project:

G:\HCL>mkdir vue-ssa

G:\HCL>cd vue-ssa

G:\HCL\vue-ssa>mkdir src

G:\HCL\vue-ssa>code .

Outside src, create index.html file
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-Application</title>
</head>
<body>
     <h1>Vue SSA </h1>
</body>
</html>
After adding html we need to run html, we need web server.

Vs code has plugin called "live server" which is built in web server- You have to install "live server" plugin(Extensions)

After running, we need to add "vue js" framwork.

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build


Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
    <!-- This is dev build -->
    <script src="https://unpkg.com/vue@3"></script>
    <!-- This is production build -->
    <!-- <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script> -->
</head>
<body>
   
</body>

</html>

.....................................................................................
.....................................................................................
DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-Application</title>
    <!-- <script src="https://unpkg.com/vue@3"></script> -->
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
</head>
<body>
     <h1>Vue SSA </h1>
     <div id="root">
         
     </div>
     <!-- Plain js to create dom element -->
     <script>
        function createElement(){
            console.log('element creation')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            document.getElementById('root').appendChild(Heading)
        }
        createElement()
     </script>
</body>
</html>


Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			 java script => binds the state(data)

...................................................................................
...................................................................................
How Vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue Organizes the UI into Smaller and Smaller UI
=>Vue Breaks complex UI into Smaller UI
   This model is called Composition

Why Composition?
=>The UI can be reused any where in the app.
=>The code maintaince is very easy,because it is independant.

           This arch is called as "component driven arch"

.....................................................................................
		  Vue js and DOM element creation
....................................................................................

in order to begin with vue, we need to understand some of the vue.js objects.

Vue offers lot of objects.

Vue has two major versions

1.vue 2.x - old and legacy version
2.vue 3.x - modern and latest version

	 There is lot of difference in vue 2 and vu3
      We are going to discuss  both versions by comparsion.	


1.Application Object/Vue instance

Pro Vue 3. (in vue 2.x)
var app = new Vue({   })


Vue 3:
1.1.Get Vue Instance

We can get Vue Instance 

A.Via Global Vue variable
B.Via ES 6 modules

.....................................................................................
			  A.Via Global Vue Instance variable	


How to get Vue instance?
 First we have to get Vue instance then only we can create application.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>

</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provided by Framework
        let vue = Vue
        console.log(vue)
    </script>
</body>

</html>
Vue instance is having so many methods(apis)
............................................

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 

What is Application Object?

  Application object is object which is container object which encapsulate vue app.

How to create Application Object?

 in order to create application object, we need to get vue instance first.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>

</head>

<body>
    <h1>Vue js Application</h1>
    <script>
        //Vue is global variable provided by Framework
        let vue = Vue
        //create application
        const app = vue.createApp()
        console.log(app.version)
    </script>
</body>

</html>
.....................................................................................
			.....................................................................................
			B.Via ES 6 Modules
.....................................................................................

ES 6 module:
  import , export ,export default.


Can we use es6 modules directly inside browser?

No, in old browsers

Yes in modern browsers

Generallly browser has no facility to links files and share code using E6 modules keyword.

How to run es 6 modules based apps inside browsers

1.via build tools.
  webpack,roolup....

2.without build tool
   using browser only
   using script tag

How to write es6 modules and run?

Using script Tag:
................
eg
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="src/index.js" type="module"></script>
</body>
</html>

src/index.js
import { name } from "./name.js";

console.log(name)

src/name.js

export const name='Subramanian'
.....................................................................................
	 ES 6 modules and html 
....................................................................................

in the last example we have used import and export  keywords inside js

Inside html we have used js via <script src="src/index.js" type="module"> 

Can we import js inside html directly?

Yes! we can

if you want to import any js code within html file, we have to use there is option called "importmap" option.
Syntax:

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script type="importmap">
        {
            "imports":{
                
            }
        }
    </script>
</head>
<body>
    <!-- <script src="src/index.js" type="module"></script> -->
</body>
</html>


eg:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script type="importmap">
        {
            "imports": {
                "name" : "./src/name.js"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import { name } from "name"
        console.log(name)
    </script>
</body>

</html>

Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.


Eg with polyfil:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "name" : "./src/name.js"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import { name } from "name"
        console.log(name)
    </script>
</body>

</html>
....................................................................................
			  Vuejs framework and es 6 module syntax

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "name" : "./src/name.js",
                "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
        }
    </script>
</head>

<body>
    <script type="module">
        import { name } from "name"
        import { createApp } from 'vue'
        console.log(name)
        const app = createApp()
        console.log(app)

    </script>
</body>

</html>
.....................................................................................
			  DOM ELEMENT Creation Using vue
			   (User interface development)

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
        }
    </script>
</head>
<body>
    <div id="root">
	
    </div>
    <script type="module">
        import { createApp } from 'vue'
        const app = createApp({
            template:`
                <h1>Hello,Vue</h1>            
            `
        })
        //insert dom into div
        app.mount('#root')
    </script>
</body>

</html>
.....................................................................................
.....................................................................................
			  User interface Development
.....................................................................................

User interface development guidelines:

1.User interface must be broken into smallar and smallar -  Compostion - Component model

2.User interface is organized in hierachal structure -  Tree Structure 
  Thats where html has been designed.
 We need to follow html tree model

 <div>
    <div>
	<div>
	   
	</div>
	
    </div>
 </div>

3.In tree model there must be one root element
..................................................................................
			
			Root Component(root Element)


Component Representations:

In React:
function Logo(){
   
   return <img src="logo.png"/>
 
}
In Angular

 @Component({
   selector:'app-logo'
   template:`<img src="logo.png"/>
 }) 
 export class Logo{

 }
....................................................................................
In Vue:
 Component is literal object.

const Logo = { 

}

Here Logo is component name, {} is object which contains component configurations.

Component configuration is divided into various segments/category


1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions

2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
 beforeCreate
 created
 beforeMount
 mounted
 beforeUpdate
 updated
 beforeUnmount
 unmounted
 errorCaptured
 renderTracked
 renderTriggered
 activated
 deactivated
 serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends


5.Misc
 name
 inheritAttrs
 components
 directives

Component Instance apis and properties:
.......................................
 Theses are used inside code , not as config.
 Most of the inbuilt properties and methods are refered by using "$"

 $data
 $props
 $el
 $options
 $parent
 $root
 $slots
 $refs
 $attrs
 $watch()
 $emit()
 $forceUpdate()
 $nextTick()

For eg:

const Logo = {
 ui:{},
 state: {},
 methods:{},
 others:{}
}
.....................................................................................
			 Vue Application Setup using build tools
.....................................................................................
Build tools are js based tools for create,manage js apps work flows.
Build tools based on npm tool.

Setup Vue Project using build tool based: CLI based apporach.
.............................................................

There are two cli tools

1.Vue-cli
  https://cli.vuejs.org/#getting-started
Vue- cli is now in maintance mode, meaning that , which is only used for creating old vue project(v2)

2.Vite
https://vitejs.dev/guide/
Next Generation Frontend Tooling project, used to create no of project types.

We are going to follow Vite base project setup

npm init vue@latest

This is abstraction for vite based project templates



>npm init vue@latest

vue-cli
 old pattern
vite
 modern pattern - recommended
 npm init vue@latest

This is abstraction for vite based project templates
 
G:\HCL>npm init vue@latest
Need to install the following packages:
create-vue@3.11.2
Ok to proceed? (y) y


> npx
> create-vue


Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes
√ Add Vue DevTools 7 extension for debugging? (experimental) ... No / Yes

Scaffolding project in G:\HCL\vue-app...

Done. Now run:

  cd vue-app
  npm install
  npm run dev

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? ... No / Yes
√ Add Vue DevTools 7 extension for debugging? (experimental) ... No / Yes

Scaffolding project in G:\IBM\2024\Aug\vuejs\vue-app...

Done. Now run:

  cd vue-app
  npm install
  npm run dev


G:\IBM\2024\Aug\vuejs>cd vue-app

G:\IBM\2024\Aug\vuejs/vue-app>npm i

G:\IBM\2024\Aug\vuejs/vue-app>npm run dev


Project Structure:

package.json
{
  "name": "vue-app",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.4.29"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0.5",
    "vite": "^5.3.1",
    "vite-plugin-vue-devtools": "^7.3.1"
  }
}
....

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

vite-config.js
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    vueDevTools(),
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

src - source folder
  |
  assets -  folder where we keep global css and image fiels
  components -  where we can keeps components of app
  App.vue
  main.js -  always must be .js file- entry

App.vue
  All Components must be saved "ComponentName.vue"
App Root Component for the application

main.js 
import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
....................................................................................
			Vue Coding style
..................................................................................

Vue coding can be classified into two category.

Vue 2.x and Vue 3.x

API Classification:
..................

1.Options API based style -Vue 2.x and Vue 3.x
2.Composition API Based style -  Vue 3.x
...................................................................................
		Components and Components Creational patterns
...................................................................................

1.Plain javascript pattern

App.js
export default {

}

It is more imperative way of creating components

2.Single File Component pattern- SFC Pattern

 It is more declarative way of creating components
 
As name suggests, All component logic inside single file

Every Component have three major segement

1.template
   Collection of html elements and vue instructions

2.javascript
   collection of variables,methods/functions

3.style
  css style for a component.

In Single File Component, we isloate very clearly into three sections

<script>
 // all js code 
</script>
<template>
  template code - html code
</template>
<style>
 css style for component
</style>
		.....................................................................................
	      Plain javascript is usefull where there is no build workflow
		     SFC is usefull where there is build work flow		   

	      Plain javascript components are saved with "FileName.js" extension
	       SFC Components are saved with "FileName.vue" extension


	       Plain javascript pattern is used for "SSA" application 
                SFC Component pattern is used for "SPA" application
...................................................................................

Plain javascript pattern and SSA application:
..............................................

src/components/App.js

//component must be exported using export default

export default {
    template:`
        <h1>Vue Component</h1>
    `
    //rest of the options goes here
}
index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports":{
                "vue":"https://unpkg.com/vue@3/dist/vue.esm-browser.js",
                "app":"./src/components/App.js"
            }
        }
    </script>
</head>

<body>
    <div id="root">

    </div>
    <script type="module">
        import { createApp } from 'vue'
        import App from 'app'
        //inject root component
        const app = createApp(App)
        app.mount("#root")
    </script>
</body>

</html>
.....................................................................................
				Component  Composition and SSA 
.....................................................................................


App -Root Component
 |
 Welcome- Component

eg:

src/components/Welcome.js
export default {
    template:`
        <h1>Hello Vue!!!</h1>
    `
}
src/components/App.js
import Welcome from "./Welcome.js";

export default {
    components: {
        Welcome
    },
    template:`
       <Welcome></Welcome>
    `
}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "vue" : "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
                "app" : "./src/compoents/App.js"
            }
        }
    </script>
</head>
<body>
    <div id="root">

    </div>
    <script type="module">
        import { createApp } from 'vue'
        import App from 'app'
        const app = createApp(App)
        //insert dom into div
        app.mount('#root')
    </script>
</body>

</html>

Task:

 Create UI Which represents Header

 App
  |
  Header
    |
    Logo
    Search Panel

.....................................................................................
.....................................................................................			             SFC Pattern
.....................................................................................

SFC pattern file, contains three segments.


1.template
   Collection of html elements and vue instructions

2.javascript
   colllection of variables,methods/functions

3.style
  css style for a component.

In SFC pattern, we isloate very clearly into three sections

SFC files are saved with ".vue" extension.


<script>
 // all js code 
</script>
<template>
  template code - html code
</template>
<style>
 css style for component
</style>

<script>
 
src/App.vue
</script>
<template>
  <div>
     <h1>Hello Vue</h1>
  </div>
</template>
<style>
</style>
...................................................................................
			 "Going foward we focus only  SFC pattern "
....................................................................................

Inside SFC , we have two style of writing code

 1.Options Api -  pure vue 2.x style
 2.Composition Api - pure vue 3.x style

 Note;
  Options Api can be written inside vue.2 and vue.3

Commonality between both patterns
			 (Options API and Composition API)

1.Code segmentation is same for both patterns

<script>
 // all js code 
</script>
<template>
  template code - html code
</template>
<style>
 css style for component
</style>

.....................................................................................
			Options API pattern
.....................................................................................

In Options API pattern we return Object called "Option" Object,  which contains necessary configuration.

<script>
//here {} is options Object
export default {
   //all configuration will go
}
</script>

Sample Configuration(Options)

<script>
 export default {
   components:[],
   props:['something']
   data() {
     return {}
   }
 }
</script>

.....................................................................................
			Composition API Pattern
.....................................................................................

=>It is vue 3.x style of writing code.
=>In this pattern, we define a component logic's using imported api functions
=>In this pattern, we can write js directly within script tag.
=>In composition pattern we have two style of coding.


		      Composition API pattern
				|
	------------------------------------------------------------
        |                                                          |
   with setup function                                     with setup attribute


with setup function:

1.It looks like Options api pattern but code refactoring has been done.
2.It looks like imperative style of compostion api.

<script>
// compostion api pattern;using setup function
export default {
    setup() {
        //all js initalization code will go
    }
}
</script>
<template>
    <h1>Compostion API pattern using setup function</h1>
</template>
<style></style>

with setup attribute:
.....................
=>It is same as setup function only but it is more declarative.
=>It has been built on the top of setup function...
=>We dont need to write extra code, vue compiler will write for us.

<script setup>
 //js code will go here
</script>
<template>
    <h1>Compostion API pattern using setup function</h1>
</template>
<style></style>

				     Vue App
		   			|
			---------------------------------------  
			With Build tool                  Without build tool
				 |				|
			  SFC Component            	 Standalone script App
				|
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps
							        												|	
		  							|
				----------------------------------------------------
				|                                     	|
	      	with setup function                           with setup attribute



Options API:
<!-- Options API pattern -->
 <script>
 export default {

 }
</script>
<template>
    <h1>Vue with Options Api</h1>
</template>

Composition API: With Setup function
....................................

<!-- Composition API pattern:with setup function -->
<script>
export default {
   //add setup fun
   setup(){
      //here all js code will go
   }
}
</script>
<template>
   <h1>Vue with Composition API: With Setup function</h1>
</template>

Composition API : With setup attribute.
<!-- Composition API pattern:with setup attribute -->
<script setup>
//  all js code will go here
</script>
<template>
   <h1>Vue with Compostion  Api -setup attribute</h1>
</template>
			.....................................................................................
			SFC- Options API
.....................................................................................

1.Component Composition:

src/components/Hello.vue
<script>
export default {

}
</script>
<template>
    <h1>Hello</h1>
</template>

src/App.vue
<script>
import Hello from './components/Hello.vue'

export default {
components:{
    Hello
 }
}
</script>
<template>
  <Hello></Hello>   
</template>


More Components:
<script>
import Hello from './components/Hello.vue'
import Hai from './components/Hai.vue'

export default {
components:{
    Hello,
    Hai
 }
}
</script>
<template>
  <Hello></Hello>
  <Hai></Hai>   
</template>
.....................................................................................
			SFC- Composition API Using setup function
.....................................................................................

1.Component Composition:
src/components/Product.vue
<!-- Using Composition api -setup function -->
<script>
export default {
    setup(){

    }
}
</script>
<template>
    <h1>Product</h1>
</template>

2.src/components/App.vue
<script>
import Product from './components/Product.vue';
export default {
    components: {
        Product
    },
    setup(){

    }
}
</script>
<template>
    <h1>Home</h1>
    <Product></Product>
</template>

.....................................................................................
			SFC- Composition API Using setup Attribute
.....................................................................................
src/components/Item.vue
<script setup>

</script>
<template>
  <h2>Item Component</h2>
</template>

src/App.vue
<script setup>
import Item from './components/Item.vue';

</script>
<template>
 <Item></Item>
</template>
.....................................................................................
			Can we mix patterns across the components
.....................................................................................

Yes!, you can but mostly recommened to follow single pattern to make code consistency.

eg:

Options Api:
src/components/Hello.vue
<script>
export default {

}
</script>
<template>
    <h1>Hello</h1>
</template>

Compostion Api with setup attribute
<script setup>
import Hello from './components/Hello.vue';
</script>
<template>
   <Hello></Hello>
</template>

Task:
 Building site layout using component composition.

Page -Root Component
  |
  Header
    |
    Search Bar
    Logo
  Footer
    |
    contact us 
    Services
  Body
    |
    section 1 - some information
    Section 2 - some information
    Section 3 - some information
 You can test with options api and composition api (setup fun and attribute)
.....................................................................................
		      Components -Registration -Advanced
.....................................................................................

A Vue Components needs to be "registered"  so that vue knows to locate its implementation when it is encountered in a template.

export default {
  components: { Hello}
}

<template>
   <Hello/>
</template>


Types of Registration:

1. Global Registration
 if components are registried globally, those components are called as "Global"
 Components

2. Local Registration
 if components are registried locally, those components are called as "Local"
 Components
eg:
export default {
  components: { Hello}
}

<template>
   <Hello/>
</template>

1. Global Registration /Global Components.

Application Object:
..................
 It is a container object which contains other objects (components...etc)

How to create Application Object?

 const app = createApp(RootComponent)

Here "app" is just variable points application Object

Application Object having lot of methods:

1.app.component()
2.app.use()
3.app.directive()
etc...


Global Components:
 Global comonents are created with application object

import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

app.component('my-component',{
  //component config
})
or

StatusBar.vue

app.component(StatusBar)

app.mount("#app")

//Retrive the Registred Component
const MyComponent = app.component('my-component',{
  //component config
})


eg;

src/components/StatusBar.vue
<script setup></script>
<template>
    <h2>Status Bar</h1>
</template>
<style>
</style>

src/main.js
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/StatusBar.vue'

const app = createApp(App)
//Global Component
app.component('StatusBar', StatusBar)

app.mount("#app")

//createApp(App).mount('#app')


How to use Global Component?

In Options Api:
..............
<script>
// import StatusBar from './components/StatusBar.vue'
export default {
    // components: {
    //     StatusBar
    // }
};
</script>
<template>
  <StatusBar />
</template>
<style></style>

Note:
 import statement is not necessary for global components.


In Composition Api:

Using setup fun:
<script>
// import StatusBar from './components/StatusBar.vue'
export default {
  setup() {},
};
</script>
<template>
  <StatusBar />
</template>
<style></style>

Using setup attribute:
<script setup>
// import StatusBar from './components/StatusBar.vue'
</script>
<template>
  <StatusBar />
</template>
<style></style>


Note:
 import statement is not necessary for global components.

.....................................................................................
			 Global Components vs Local Components
.....................................................................................
=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").

=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.
	....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).

This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   
	Vue supports both cases , but highly recommened is Pascal Case

=>This can affect long-term maintainability similar to using too many global variables.

=>Global Components need to be imported inside any where


eg:

<script setup>
</script>
<template>
    <!-- Pascal Case -->
  <StatusBar />
  <!-- keb-case -->
   <status-bar></status-bar>
</template>
<style></style>

.....................................................................................
				Templates
....................................................................................

Template is representation of "View"

View is runtime representation of user interface
View is Typically DOM tree.


Types of templates:

1.Static template
   It is having only pure html tags

2.Dynamic templates
   Template is having html code and vue instructions ,and js code

Vue instructions are special symbols and notations.

Project:
 npm init vue@latest


Static Template:
<script>
export default {}
</script>
<template>
  <div>
     <header>
       <h2>Blog</h2>
     </header>
     <div>
        <section>
           <p>This is Vue js</p>
        </section>
        <section>
          <p>This is Html </p>
       </section>
       <section>
        <p>This is C# </p>
     </section>
     </div>
     <footer>
      <p>This is footer</p>
     </footer>
  </div>
</template>
....................................................................................
			 Dynamic templates
....................................................................................

Dynamic templates includes "vue instructions,js,html"

Vue instructions are other wise called as "Data binding"

Data binding:
  Passing data from the component to View and View Component.

User interface is broken down into two sections:

1.Design - UI Markup

2.Logic  - Javascript 

Any User interface development follows some design pattern.

Popular design patterns for ui developement

1.MVC - Model View Controller
   Angular,Spring MVC,.Net MVC
2.Flux 
   React
3.MVVM - Model View - View Model
  Knockout.js
  ember.js

Vue.js follows MVC Design pattern and also Flux Design pattern -Hybrid design pattern.

Mostly Vue.js  follows MVC.

According MVC

1.Template section is called View
2.script section is Called Model and Controller

<script>
  model and controller code
</script>
<template>
  view
</template>

 data binding is nothing but moving data between script to template and template to script.

We have different types of data binding.

1.Interpolation
2.Property and props Binding
3.Attribute Binding
4.Event Binding
5.Two way data binding
6.Class and Style binding

Component =  {Model + Controller + View }
.....................................................................................
			Interpolation
.....................................................................................

Transfering data (state) from Controller to view.

State:
  State can be represented in 2 ways.

1.Primitives
   numbers,strings,booleans
2.Objects and Collections
   Literal objects and arrays
.....................................................................................
			Interpolation -SFC -Options API pattern
.....................................................................................

Data configuration:

let options = {
data:?
props: ?
methods: ?
}
syntax:

export default {
  data(){
     must return object -state
     return {}
  }
}

How to bind /show the variable inside view?
 {{Variable}} - interpolation


src/App.vue
<script>
export default {
    data() {
        //return state
        return {
            name: 'Subramanian Murugan'
        }
    }
}
</script>
<template>
    <h1>Profile</h1>
    <div>
        <h3>Name :{{ name }}</h3>
    </div>
</template>

More data:
 numbers
 booleans
 objects

<script>
export default {
    data() {
        //return state
        return {
            name: 'Subramanian Murugan',
            status: true,
            age: 18,
            address: {
                city: 'Coimbatore',
                state: 'Tamil Nadu',
                zipcode: '611111'
            }
        }
    }
}
</script>
<template>
    <h1>Profile</h1>
    <div>
        <h3>Name :{{ name }}</h3>
        <h3>Age : {{ age }}</h3>
        <h3>Status : {{ status ? 'Available' : 'Not Available' }}</h3>
        <address>
            <p>{{ address.city }}</p>
            <p>{{ address.state }}</p>
            <p>{{ address.zipcode }}</p>
        </address>
    </div>
</template>


Create separate Component

src/components/Profile.vue
<script>
export default {
    data() {
        //return state
        return {
            name: 'Subramanian Murugan',
            status: true,
            age: 18,
            address: {
                city: 'Coimbatore',
                state: 'Tamil Nadu',
                zipcode: '611111'
            }
        }
    }
}
</script>
<template>
    <h1>Profile</h1>
    <div>
        <h3>Name :{{ name }}</h3>
        <h3>Age : {{ age }}</h3>
        <h3>Status : {{ status ? 'Available' : 'Not Available' }}</h3>
        <address>
            <p>{{ address.city }}</p>
            <p>{{ address.state }}</p>
            <p>{{ address.zipcode }}</p>
        </address>
    </div>
</template>

src/App.vue
<script>
import Profile from './components/Profile.vue'
export default {
  components: {
    Profile
  }
}
</script>
<template>
  <Profile></Profile>
  <Profile></Profile>
  <Profile></Profile>
  <Profile></Profile>
  <Profile></Profile>
</template>

Task:
 Create simple Product Component which displays product informations
 id,name,price,qty,description,stock

.....................................................................................
		      Interpolation-SFC-Composition API pattern
....................................................................................

Using Setup function:

<script>
export default {
    setup() {
        //declare state as simple variables
        const id = 1;
        const name = 'Subramanian'
        const status = true
        const address = {
            city: 'Coimbatore',
            state: 'TN'
        }
        //return object
        // return {
        //     id: id,
        //     name: name,
        //     status: status,
        //     address: address
        // }
        return {
            id,
            name,
            status,
            address
        }
    }
}
</script>
<template>
    <h1>Profile Information</h1>
    <h3>Name :{{ name }}</h3>
    <h3>Age : {{ age }}</h3>
    <h3>Status : {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}</p>
        <p>{{ address.state }}</p>
        <p>{{ address.zipcode }}</p>
    </address>
</template>

Using setup attribute:
......................
<script setup>
const id = 1;
const name = 'Subramanian'
const status = true
const address = {
    city: 'Coimbatore',
    state: 'TN'
}
</script>
<template>
    <h1>Profile Information</h1>
    <h2>id : {{id }}</h2>
    <h3>Name :{{ name }}</h3>
    <h3>Age : {{ age }}</h3>
    <h3>Status : {{ status ? 'Available' : 'Not Available' }}</h3>
    <address>
        <p>{{ address.city }}</p>
        <p>{{ address.state }}</p>
        <p>{{ address.zipcode }}</p>
    </address>
</template>
.....................................................................................
			  Component Composition
..................................................................................

src/components/Address.vue
<script setup>
const address = {
    city: 'Coimbatore'
}
</script>
<template>
    <h4>City: {{ address.city }}</h4>
</template>
src/components/User.vue
<script setup>
import Address from './Address.vue';
const id = 1
const name = 'Subramanian'
</script>
<template>
    <h1>Id : {{ id }}</h1>
    <h2>Name : {{ name }}</h2>
    <Address></Address>
</template>

src/App.vue
<script setup>
import User from './components/User.vue';

</script>
<template>
    <User></User>
</template>
.....................................................................................				 Directives
...................................................................................
What is Directive?
    Directive is object which helps to create custom elements and attributes.
    Directives enchances existing html elements- we can extend the basic functionality of HTML elements
   We are going to add new behaviour to the HTML elements.
 
Custom Elements and attributes:
..............................
<h1>Hello</h1>
  h1 is built in html element, it is part of the language.

Html Runtime:
 when html runtime encounters h1 element, it knows how to represent.

<hello>
<profile>
<address>
    
  These looks like html elements but not.
   Html runtime when encounters these elements, internally it throws Runtime Error.
  called "UnKnowElementException".

if "UnKnowElementException" is thrown , browser automatically converts it into "PlainText" Node, renders it.

In 2007,w3c introduced new feature called "Custom element feature", According to custom element, we can introduce custom element.

How to teach browser to understand custom element?
  via "js"

There is api customElements.define('popup-info',PoupInfo);


Custom attributes:
..................
   
 Similar to custom elements, we can create custom attributes through which we can add new behaviour to existing elements
 
 <div style>
       |
     attribute - built in

<div my-if>
      |  
     attribute -  custom

In Frameworks like angular,vue, we have feature called directives

		 "Every component is directive/custom element"

<app-drawer>
<profile>
			 Directives
	-----------------------------------------------------------
	|                                                      |
    Custom Element                                      Custom Attribute
    (Component)                                        (Attribute Directive)


....................................................................................
			     Attribute Directives
....................................................................................
.....................................................................................
			 Custom attribute  


1.Built in element Attributes

 <img src="" alt="">
       |      |
   Attributes - Built in attributes

Browser knows how to put logic to src and alt.

2.Custom attributes on existing html elements

<img customAttribute />
        | 
     custom attribute
How to teach browser to parse custom Attributes 
  "Through Javascript"

eg: Vue rendered page:

<div id="app" data-v-app="">

.....................................................................................
	Vue.js Helps to add Custom attributes on existing elements via "Directives" -		    	       Attribute Directives
.....................................................................................
Vue js attribute directive syntax:

v-directiveName


Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

Special Attributes
key
ref
is

Built in custom elements(custom directives/components)
.......................................................
<Transition>
<TransitionGroup>
<KeepAlive>
<Teleport>
<Suspense>

Special Elements
<component>
<slot>
<template>

<script setup>
const firstName="Subramanian"
const lastName='Murugan'
</script>
<template>
<div>
    <h1>Data binding using interpolation {{name}}</h1>
    <h1>Data binding using v-text</h1>
    <h2 v-text="`Name ${firstName}  ${lastName} `"></h2>
    <h1>Data binding using v-html</h1>
    <h2 v-html="`Name ${name}`"></h2>

</div>
</template>
...................................................................................
			v-bind
..................................................................................

v-bind attach html attributes or components values dynamically.

Binding means attach value to the attribute.

Types of binding

1.static binding
2.dynamic binding

1.static binding

 <img src="logo.png">
  
   here the value of src cant be changed once it is rendered
 

2.dynamic binding

  <img v-bind:src="variableHoldingImageValue"/>

  let variableHoldingImageValue="logo.png"

 v-bind:src
   is dynamic binding, that src value can be changed dynamically.


eg:
<script setup>
const imgUrl = "/src/assets/logo.svg";
const isHidden = true;
const isEnabled= false 
</script>

<template>
  <div>
    <h1>Static Binding</h1>
    <img src="./assets/logo.svg" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic Binding</h1>
    <img v-bind:src="imgUrl" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic binding with show and hide</h1>
    <article v-bind:hidden="isHidden">This is article</article>
  </div>
  <div>
    <h1>Dynamic binding with enable and disable</h1>
    <button v-bind:disabled="isEnabled">button</button>
  </div>
</template>
<style></style>
.....................................................................................
.....................................................................................
			Code Refactoring for v-bind Directive
.....................................................................................

Full syntax
<button v-bind:disabled="isEnabled">button</button>

Short cut:
<button :disabled="isEnabled">button</button>


Eg:
<script setup>
const imgUrl = "/src/assets/logo.svg";
const isHidden = true;
const isEnabled = false;
</script>

<template>
  <div>
    <h1>Static Binding</h1>
    <img src="./assets/logo.svg" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic Binding</h1>
    <img :src="imgUrl" height="100" width="100" />
  </div>
  <div>
    <h1>Dynamic binding with show and hide</h1>
    <article :hidden="isHidden">This is article</article>
  </div>
  <div>
    <h1>Dynamic binding with enable and disable</h1>
    <button :disabled="isEnabled">button</button>
  </div>
</template>
<style></style>
.....................................................................................
			  Property binding- props binding
....................................................................................

Component contains 
1.user interface
2.data 

if you create component which contains ui and data, after rendering if you want to supply different data for that component not possible.

if i create profile component

<script setup>
import Address from "./Address.vue";
let firstName = "Subramaian";
let lastName = "Murugan";
let status = true;
</script>
<template>
  <div>
    <h2>{{ firstName }} {{ lastName }}</h2>
    <h2>{{ status ? "Available" : "Not Available" }}</h2>
    <Address />
  </div>
</template>
<style></style>

here firstName,lastName ,status is "tightly coupled" with this component.

what if i want to display different profile information,you cant reuse the component

Solution:
  You should create component that should be configurable.

You have to pass different data to the component during runtime.

How to configure the component which accepts data?

  "Props or or property pattern.

Props or property is way of passing data to the component.

Props are passed from the parent component to child component.
.....................................................................................
	.....................................................................................
			Props and Options api
.....................................................................................

Props Pattern

Syntax:

From the parent compoenent template

<template>
   <Child  title="value" :value="variable" />
</template>

  <Child  title="value" :value="variable" />
	   |              |
        props           props="variable"

here title is property which value is static
:value is also property which value is dynamic


Parent: src/App.vue
<script>
import Profile from './components/Profile.vue'
export default {
  components: { Profile },
  data() {
    return {
      firstName: 'Subramanian',
      lastName: 'Murugan',
      status: true
    }
  }
}
</script>
<template>
  <Profile title="Profile" :firstName="firstName" :lastName="lastName" :status="status"></Profile>
  <Profile title="Profile" firstName="Ram" lastName="Samy" status="true"></Profile>
  <Profile title="Profile" firstName="Karthik" lastName="Samy" status="true"></Profile>
  <Profile title="Profile" firstName="John" lastName="Samy" status="true"></Profile>
  <Profile title="Profile" firstName="Abhi" lastName="Samy" status="true"></Profile>

</template>

Child: src/components/Profile.vue
<script>
export default {
    props: ['title', 'firstName', 'lastName', 'status']
}
</script>
<template>
    <div>
        <h1>Profile Info </h1>
        <h2>{{ firstName }} {{ lastName }}</h2>
        <h2>{{ status ? "Available" : "Not Available" }}</h2>
    </div>
</template>
....................................................................................
			 Props and setup function


Parent: src/App.vue
<script>
import Profile from './components/Profile.vue'
export default {
    components: { Profile },
    setup() {
        const firstName = 'Subramanian'
        const lastName = 'Murugan'
        const status = true
        return {
            firstName,
            lastName,
            status
        }
    }
}
</script>
<template>
    <Profile title="Profile" :firstName="firstName" :lastName="lastName" :status="status"></Profile>
    <Profile title="Profile" firstName="Ram" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="Karthik" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="John" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="Abhi" lastName="Samy" status="true"></Profile>

</template>

Child src/components/Profile.vue
<script>
export default {
    props: ['title', 'firstName', 'lastName', 'status'],
    setup(){

    }
}
</script>
<template>
    <div>
        <h1>Profile Info </h1>
        <h2>{{ firstName }} {{ lastName }}</h2>
        <h2>{{ status ? "Available" : "Not Available" }}</h2>
    </div>
</template>
....................................................................................
			Compostion api : props - setup attribute
.....................................................................................

Parent: src/App.vue
<script setup>
import Profile from './components/Profile.vue'
const firstName = 'Subramanian'
const lastName = 'Murugan'
const status = true
</script>
<template>
    <Profile title="Profile" :firstName="firstName" :lastName="lastName" :status="status"></Profile>
    <Profile title="Profile" firstName="Ram" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="Karthik" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="John" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="Abhi" lastName="Samy" status="true"></Profile>

</template>

Child src/Profile.vue
<script setup>
import Profile from './components/Profile.vue'
const firstName = 'Subramanian'
const lastName = 'Murugan'
const status = true
</script>
<template>
    <Profile title="Profile" :firstName="firstName" :lastName="lastName" :status="status"></Profile>
    <Profile title="Profile" firstName="Ram" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="Karthik" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="John" lastName="Samy" status="true"></Profile>
    <Profile title="Profile" firstName="Abhi" lastName="Samy" status="true"></Profile>

</template>

Task:
  Product Component with Props 
  id,name,price,qty
........................................................................
.....................................................................................
			Property Validation -Composition setup attribute
.....................................................................................

Some times i want to enforce the property data type validation, which is only for runtime verification.

For eg:
 I have property called age
 i need to define rule for age that must be be number, it should not be string.

Simple Syntax:

1.defineProps(['age','name'])

Validation Syntax:

2.defineProps({
 age:Number,
 id:[Number,String] //can be string or can be number
 name:{ 
   type:String,
   required:true,
   default:'foo'
  
 },
 status: {
   validator(value){
      return ['OK','NOTOK','Success','Failure'].includes(value)
   }
 }
})


Runtime data types:
1.Number
2.String
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol


Eg:
src/components/User.vue
<script setup>
const props = defineProps({
  id: [Number, String],
  name: String,
  email: String,
  status: {
    validator(value) {
      return ["Available", "NotAvailable"].includes(value);
    },
  },
});
</script>
<template>
  <div>
    <h1>User information</h1>
    <h2>Id {{ props.id }}</h2>
    <h2>Name {{ props.name }}</h2>
    <h2>Email {{ props.email }}</h2>
    <h2>Status {{ props.status }}</h2>
  </div>
</template>
<style></style>





src/App.vue
<script setup>
import User from "./components/User.vue";
let id =1;
let name=34
let email="karthik@gmail.com"
let status ="Available"
</script>
<template>
  <div>
    <!-- Static Property -->
    <User id="1" name="subu" status="Available" email="subu@gmail.com" />
    <User id="2" name="murugan" status="Available" email="murugan@gmail.com" />
    <!-- Dynamic property -->
    <User :id="id" :name="name" :status="status" :email="email" />
  </div>
</template>
<style></style>


After running you can see in the console

App.vue?t=1722573470334:56 [Vue warn]: Invalid prop: type check failed for prop "name". Expected String with value "34", got Number with value 34. 
  at <User id=1 name=34 status="Available"  ... > 
  at <App>

It shows only warning not error, because js verifies the type only during runtime.
....................................................................................
			Default Props
....................................................................................

if you dont pass value from parent to child as prop, the default prop can be supplied

src/components/Header.vue
<script setup>
const props = defineProps({
  title: {
    default: "IBM",
  },
});
</script>
<template>
  <header>
    <h1>{{ props.title }}</h1>
  </header>
</template>
<style></style>

src/App.vue
<script setup>
import Header from "./components/Header.vue";
</script>
<template>
  <Header />
  <Header title="google" />
</template>
<style></style>

..................................................................................
			One way Data Flow model
...................................................................................

All Props are passed from parent to child, where child component update the properties?
			"Props are read only"


src/components/Header.vue
<script setup>
const props = defineProps({
  title: {
    default: "IBM",
  },
});
//update the props
props.title = "Microsoft";
</script>
<template>
  <header>
    <h1>{{ props.title }}</h1>
  </header>
</template>
<style></style>


src/App.vue
<script setup>
import Header from "./components/Header.vue";
</script>
<template>
  <Header title="google" />
</template>
<style></style>

Output:
[Vue warn] Set operation on key "title" failed: target is readonly. Proxy(Object) {title: 'google'}
....................................................................................

..................................................................................
			One way Data Flow model
...................................................................................

All Props are passed from parent to child, where child component update the properties?
			"Props are read only"


src/components/Header.vue
<script setup>
const props = defineProps({
  title: {
    default: "IBM",
  },
});
//update the props
props.title = "Microsoft";
</script>
<template>
  <header>
    <h1>{{ props.title }}</h1>
  </header>
</template>
<style></style>


src/App.vue
<script setup>
import Header from "./components/Header.vue";
</script>
<template>
  <Header title="google" />
</template>
<style></style>

Output:
[Vue warn] Set operation on key "title" failed: target is readonly. Proxy(Object) {title: 'google'}
....................................................................................

Case Study:

You have to create Customer Component having customer details

1.Basic Customer information -  id,firstName,lastName,status
2.Address - street,city,state,country,zipcode
3.Avatar -Customer Image
4.Location - lat,lng

App-->props--Customer--->Address,Avatar,Location
<Customer></Customer>

Customer:
 Customer basic details
 <Avatar/>
 <Address :street="props.street"/>
 <Location/>
Prop validation:
  You can set validation rules for your component

................................&&&&&&&&&&&&&&&&&....................................
			Even Handling - Event binding
....................................................................................
Event handling is one of the most popular concept in javascript as part of DOM programming.
Event handling helps to interact with user.
Events  are signals triggered by user or system, send to os system, the software or hardware reacts according to the event.

Events are classified into two category

1.Hardware events
   Triggered by user or system, interacts with hardware devices   
eg:
  Mouse events
    onclick,ondblclick,onmouseenter...
  https://www.w3schools.com/jsref/obj_mouseevent.asp
  Keyboard events
   onkeypress,onkeydown
  https://www.w3schools.com/jsref/event_onkeypress.asp
  Touch events
  ontouchstart,ontouchend
  https://www.w3schools.com/jsref/obj_touchevent.asp

2.Application events
   attached with objects called dom objects
  onload,oncomplete
...................................................................................
		        How event handling works

Event handling has been designed based on the design pattern called "pub-sub"/observer design pattern.

There are two actors:
1.Producer
   The producer is something who sends signals(events - name of the event and data assoicated) to the listener
2.Listener
  The Listener is someone who waits/listens for event.
  Once the event is given who reacts/respond

In js :
 Listener is function.

//event is just reference to the Event Object having information about event, and data
function listener(event){
     event.target.value
}
event object is a bridge between producer and listener

In javascript , events are given by language itself.

events are started with "on+eventName" - 
 onclick="listener"

addEventListener('click',listener)
listeners are plain js functions with event object reference arg

Frameworks like vue,react,angular who adds their own abstractions.

We can attach event on any dom element which could be application or hardware
...................................................................................

Vue Js and event handling:
..........................

Vue attaches events with any element with help of directive
                          "v-on"

Syntax:
1. v-on:NameOftheEvent="listener" -  v-on:click="update"
2. @click="listener" - @click="update"
.....................................................................................		 	Event Handling (Declration)-Options API Pattern
.....................................................................................

create new project

npm init vue@lastest
   vue-eventhandling  

Simple Event handler declaration:

src/App.vue
<script>
export default {
  components: {},
  data() {
    return {};
  },
  //listener
  methods: {
    //hello listener
    hello(evt) {
      console.log("hello is called");
    },
    hai(evt) {
      console.log("hai is called");
    },
  },
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>

.....................................................................................		 Event Handling (Declration)-Composition API Pattern -Setup function
.....................................................................................

src/App.vue
Simple Event Declaration:
<script>
export default {
  setup() {
    //event handler
    function hello() {
      console.log("hello");
    }
    function hai() {
      console.log("hai");
    }
    //must return function
    return {
      hello,
      hai,
    };
  },
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>


Arrow version of Event handler:
<script>
export default {
  setup() {
    //event handler : ES 5 Syntax
    const hello = (evt) => {
      console.log("hello");
    };
    const hai = (evt) => {
      console.log("hai");
    };
    //must return function
    return {
      hello,
      hai,
    };
  },
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>

....................................................................................		 Event Handling (Declration)-Composition API Pattern -Setup attribute
.....................................................................................

<script setup>
const hello = (evt) => {
  console.log("hello");
};
const hai = (evt) => {
  console.log("hai");
};
</script>
<template>
  <div>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>
  </div>
</template>
<style></style>
.....................................................................................
.....................................................................................
		 How to attach more than one listener on single DOM Element
...................................................................................

<dom v-on:eventName="listener" v-on:eventName="listener">
<dom @eventName="listener" @eventName="listener">

<dom v-on="{mouseenter:onMouseEnter,mouseleave:onMouseLeave}">

<script setup>
const onMouseEnter = (evt) => {
  console.log("enter");
};
const onMouseLeave = (evt) => {
  console.log("leave");
};
</script>
<template>
  <div v-on="{mouseenter:onMouseEnter,mouseleave:onMouseLeave}">
        Touch Me
  </div>
</template>
<style></style>
....................................................................................
		  How to pass data to the listener function
..................................................................................
<script setup>
const onUpdate = (name) => {
  console.log(name);
};
</script>
<template>
  <button @click="onUpdate('Subramanian')">Send</button>
</template>
<style></style>

What if i want to pass event object also.

<script setup>
const onUpdate = (name,evt) => {
  console.log(name);
};
</script>
<template>
  <button @click="onUpdate('Subramanian',$event)">Send</button>
</template>
<style></style>
....................................................................................
....................................................................................
			 State (Reactive State) and Event Handling
....................................................................................

We have seen how to represent data, but we have not seen how to change data.

.....................................................................................
			State Mutation(update) in Options API
.....................................................................................

src/components/Counter.vue

<script>
export default {
  data() {
    //reactive state
    return {
      counter: 0,
    };
  },
  methods: {
    inc() {
      //access reactive state variable inside listener
      this.counter++; //mutation happens
    },
  },
};
</script>
<template>
  <div>
    <h1>Counter App</h1>
    <h2>Value : {{ counter }}</h2>
    <button @click="inc">+</button>
  </div>
</template>
<style></style>

src/App.vue
<script>
import Counter from "./components/Counter.vue";
export default {
  components: {
    Counter,
  },
};
</script>
<template>
  <Counter />
</template>
<style></style>
.....................................................................................
		       Multi State-Options API
.....................................................................................

src/components/Review.vue
<script>
export default {
  data() {
    //reactive state
    return {
      like: 0,
      dislike: 0,
    };
  },
  methods: {
    onLike() {
      //access reactive state variable inside listener
      this.like++; //mutation happens
    },
    onDislike() {
      //access reactive state variable inside listener
      this.dislike++; //mutation happens
    },
  },
};
</script>
<template>
  <div>
    <h1>Review App</h1>
    <h2>Like : {{ like }} Dislike {{ dislike }}</h2>
    <button @click="onLike">Like</button>
    <button @click="onDislike">DisLike</button>
  </div>
</template>
<style></style>

src/App.vue

<script>
import Review from "./components/Review.vue";
export default {
  components: {
    Review,
  },
};
</script>
<template>
  <Review />
</template>
<style></style>
....................................................................................
			 Dynamic props - Passing state as prop
....................................................................................

//Child Component
src/components/ReviewDashboard.vue

<script>
export default {
  props: ["like", "dislike",'onLike','onDislike'],
};
</script>
<template>
  <div>
    <h1>ReviewDashboard</h1>
    <h2>Like : {{ like }} Dislike {{ dislike }}</h2>
    <button @click="onLike">Like</button>
    <button @click="onDislike">DisLike</button>
  </div>
</template>
<style></style>



src/components/Review.vue

<script>
import ReviewDashboard from "./ReviewDashboard.vue";

export default {
  components: {
    ReviewDashboard,
  },
  data() {
    //reactive state
    return {
      like: 0,
      dislike: 0,
    };
  },
  methods: {
    onLike() {
      //access reactive state variable inside listener
      this.like++; //mutation happens
    },
    onDislike() {
      //access reactive state variable inside listener
      this.dislike++; //mutation happens
    },
  },
};
</script>
<template>
  <div>
    <ReviewDashboard
      :like="like"
      :dislike="dislike"
      :onLike="onLike"
      :onDislike="onDislike"
    />
  </div>
</template>
<style></style>
.....................................................................................

Task:

 You must have component called Rating component.

 Reating Component state

   state= {
     name:'Movie'
     actor:'',
     director:''
     rating: { 
        like:0,
        dislike:0  
     }
   }

1.Create "Movie"  Component which has state and biz logic

2.Create "MovieDashboard" Component which should show only movie Data (name,actor,director)

3.Create "MovieRating" Component which should display only rating(like,dislike)
.....................................................................................
.....................................................................................
			Composition API and State Mutation
..................................................................................... 
....................................................................................
			   Reactivity
....................................................................................

What is Reactivity?
  Reactivity is one of the core vue js concept.
Component state are "reactive javascript objects"

The word reactivity means "changing" the state(object),whenever changes happen it publishes some events, based on events,reactions happens.

Programming work flow in general

int x =10;
int y =20;

int result = x + y

when you compute this code, the runtime will execute instructions top-down pattern.
if there is change in variable (like x or y), will not update result variable
 -Sequential programming model.

What if i want to update the "result" variable value automatically when ever x or y changes.

eg:
Excel spreed sheet is one of the best eg for reactivitity programming

eg;

let A1=1
let A2=2
let A3 =A1+A2
console.log(A3) => 3

A2=4
console.log(A3) => 5

How to apply the same programming in js?

Here when you mutate A1 or A2, does not change automatically.

We can wrap this code inside function

 let A3
 function update(){
   A3 = A1 + A2
 }

in order get fresh value, we have to re-run the code that updates A3

Pointers:

1.There should be some update function, which produces a "side effect /effect".
  if any function which changes the state of the program called side effect.

2.Here ,A1 and A2 are considered dependencies of the side effect, because which helps makes side effects.
  According to dependencies, this effect is said to be "subscriber"

When ever "A1 and A2" changed, we need to invoke "update" function,which cause side effects.

It looks like event driven programming (Pub-Sub Pattern /Observerable and Observer) 

 function whenDepChange(update){
     update()
 }

 let A3
 function update(){
   A3 = A1 + A2
 }

 whenDepChange(function(){
     A3 = A1 + A2
 })
 whenDepChange(update)

Role of whenDepchange function:
................................

1.Tracking the dependencies,
    By evaulating the expression A1 and A2 ,Whether any one of them is read or not.

Vue Internal Reactivity WorkFlow:

Tracker--->triggers--whenDepChange--->runs update function---returns modified state
	
...................................................................................
...................................................................................
			  Vue js and Reactivity

Vue js uses "Reactivity subsystem" in order to track all state variables, when ever which changes happen, it inform the vue engine for re render process..


In Options Api pattern,

export default {
  
  data(){
   let count =0
    return {
      count:count
    }
  }

}
inside data function , if you return object, by default it is reactive, meaning that any changes detected, it starts re render ui.


In Compostion api pattern: whether is setup fun or setup attribute

<script>
export default {
 
   setup() {
    let count =0;
	return {
	  count:count
       }
   }  

}
</script>
by default setup function /setup attribute does not return reactive state..(it is normal object)

In options api every property we return is reactive, but in compostion api we can restrict reactive and non reactive.

How to declare reactive state/ how to attach reactivity feature?

Compostion Api reactive methods:
................................
ref()
computed()
reactive()
readonly()
watchEffect()
watchPostEffect()
watchSyncEffect()
watch()

ref():
 It is function which returns Object, not value

function ref<T>(value: T): Ref<UnwrapRef<T>>

interface Ref<T> {
  value: T
}
..................................................................................
			 ref-Composotion api using setup function

<script>
import { ref } from "vue";
export default {
  setup() {
    //variables must be converted into reactive
    let like = ref(0);
    let dislike = ref(0);
    console.log(like.value);

    //listener
    const onLike = () => {
      console.log("onLike");
      like.value++;
    };
    const onDislike = () => {
      console.log("onLike");
      dislike.value++;
    };

    //this object which contains variables not reactive by default
    return {
      like,
      dislike,
      onLike,
      onDislike
    };
  },
};
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ like }} Dislike {{ dislike }}</h1>
    <button @click="onLike">Like</button>
    <button @click="onDislike">Dislike</button>
  </div>
</template>
<style></style>
.....................................................................................
			 setup attribute and ref
......................................................................................	
<script setup>
import { ref } from "vue";
//variables must be converted into reactive
let like = ref(0);
let dislike = ref(0);
//listener
const onLike = () => {
  console.log("onLike");
  like.value++;
};
const onDislike = () => {
  console.log("onLike");
  dislike.value++;
};
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ like }} Dislike {{ dislike }}</h1>
    <button @click="onLike">Like</button>
    <button @click="onDislike">Dislike</button>
  </div>
</template>
<style></style>
..................................................................................
                       Passing Explicit Values to Listener

<!-- Passing values to listener -->
<script setup>
import { ref } from "vue";
//variables must be converted into reactive
let like = ref(0);
let dislike = ref(0);
//listener
const onLike = (incrementer, evt) => {
  like.value += incrementer;
};
const onDislike = () => {
  dislike.value++;
};
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ like }} Dislike {{ dislike }}</h1>
    <button @click="onLike(4, $event)">Like</button>
    <button @click="onDislike">Dislike</button>
  </div>
</template>
<style></style>
.....................................................................................
			Inline Listener
....................................................................................

Without using explicit listener

<script setup>
import { ref } from "vue";
let like = ref(0);
let dislike = ref(0);
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ like }} Dislike {{ dislike }}</h1>
    <button @click="like++">Like</button>
    <button @click="dislike++">Dislike</button>
  </div>
</template>
<style></style>
....................................................................................
			 Reactive Objects
..................................................................................

As of now, we have declared reactive primtive variables, so how to declare reactive state.
 
let count = ref(0) //primitive variable

let comments = reactive({
  like:0,
  dislike:100
})

ref with Reactive Object:
........................
<script setup>
import { ref } from "vue";
let review = ref({ like: 0, dislike: 0 });
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ review.like }} Dislike {{ review.dislike }}</h1>
    <button @click="review.like++">Like</button>
    <button @click="review.dislike++">Dislike</button>
  </div>
</template>
<style></style>

ref with Reactive Object and Listener
<script setup>
import { ref } from "vue";
let review = ref({ like: 0, dislike: 0 });

const onLike = ()=>{
    review.value.like++
}
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ review.like }} Dislike {{ review.dislike }}</h1>
    <button @click="onLike">Like</button>
    <button @click="review.dislike++">Dislike</button>
  </div>
</template>
<style></style>

in order to mutate objects we have special function called "reactive" function.

<script setup>
import { reactive } from "vue";
let review = reactive({ like: 0, dislike: 0 });

const onLike = ()=>{
    review.like++
}
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ review.like }} Dislike {{ review.dislike }}</h1>
    <button @click="onLike">Like</button>
    <button @click="review.dislike++">Dislike</button>
  </div>
</template>
<style></style>
.....................................................................................
...................................................................................	              How to avoid deep conversion with Reactive Nested object	
....................................................................................

shallowReactive:
  shallow version of reactive()
 Unlike reactive there is no deep conversion.... only root properties are reactive 

<script setup>
import { shallowReactive } from 'vue'

//deep nesting
const comments = shallowReactive({
    like: 0,
    dislike: 0,
    recommend: {
        rating: {
            value: 0
        }
    }
})

</script>
<template>
    <div>
        <h1>Reactive State</h1>
        <h1>Like : {{comments.like}} Dislike {{comments.dislike}} Rating {{comments.recommend.rating.value}}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>

    </div>
</template>
...................................................................................
		   Reactivity ,State Mutation,and Object Destructuring
...................................................................................
After reactive object destructuring , can we do state mutations?
  Reactivity will be lost once if the object is destructured..

1.toRef - single property
2.toRefs - multiple property


<script setup>
import { reactive, toRefs } from "vue";
//Object destruction
let { like, dislike } = toRefs(reactive({ like: 0, dislike: 0 }));

const onLike = () => {
  like.value++;
};
</script>
<template>
  <div>
    <h1>Review Component</h1>
    <h1>Like {{ like }} Dislike {{ dislike }}</h1>
    <button @click="onLike">Like</button>
    <button @click="dislike++">Dislike</button>
  </div>
</template>
<style></style>
....................................................................................
				List Rendering -Arrays
....................................................................................
Arrays:
 =>Arrays are basic datastructure which is used to render collection of data
 =>Arrays are dynamic

Arrays and UI:
 if you want render more data, then array is used.
Arrays can help to build in UI layouts in various ways


UI layouts:
 are built with help of arrays.

1.List View
 <ul>
   <li>
 </ul>
2.Card View layout
  <div><header><section>
3.Grid view
  table

....................................................................................
				List Rendering -Arrays
....................................................................................
Arrays:
 =>Arrays are basic datastructure which is used to render collection of data
 =>Arrays are dynamic

Arrays and UI:
 if you want render more data, then array is used.
Arrays can help to build in UI layouts in various ways


UI layouts:
 are built with help of arrays.

1.List View
 <ul>
   <li>
 </ul>
2.Card View layout
  <div><header><section>
3.Grid view
  table

.....................................................................................
.....................................................................................
			   v-for directive
....................................................................................
  This directive used for array rendering and object rendering.

<ul>
   <li v-for="(variable,index) in array">
</ul>

Simple List

<script setup>
import {reactive} from 'vue'
const List = reactive(["Subramanian", "Karthik", "Murugan"]);
</script>
<template>
 <div>
    <ul>
      <li v-for="name in List">
         {{name}}
      </li>
    </ul>
 </div>
</template>


Objects/Array List:
...................
<script setup>
import { reactive } from "vue";
import TODOS from "./mock-data/Todos";
const todosList = reactive(TODOS);
</script>
<template>
  <div>
    <ul>
      <li v-for="todo in todosList">
        {{ todo.title }}
      </li>
    </ul>
  </div>
</template>

....................................................................................
			   List with Index
....................................................................................
<script setup>
import { reactive} from 'vue'
import TODOS from './mock-data/todos'

const todos = reactive(TODOS)

</script>
<template>
    <div>
      <ul>
        <li v-for="(todo,index) in todos">
          <!-- <span>{{index}} {{todo.title}}</span> -->
          <span>{{todo.title}}</span>
        </li>
      </ul>

    </div>
</template>
....................................................................................	
....................................................................................
			   Nested List
...................................................................................

The outter arry is iterated with "Item in Array"
The inner array is iterated with "Item of NestedArray"


<script setup>
import { reactive } from 'vue'

const persons = [
    {
        id: 1,
        name: 'A',
        friends: [
            {
                name: 'F1'
            },
            {
                name: 'F2'
            },
            {
                name: 'F3'
            }
        ]
    },
    {
        id: 2,
        name: 'B',
        friends: [
            {
                name: 'BF1'
            },
            {
                name: 'BF2'
            },
            {
                name: 'BF3'
            }
        ]
    },
    {
        id: 3,
        name: 'C',
        friends: [
            {
                name: 'CF1'
            },
            {
                name: 'CF2'
            },
            {
                name: 'CF3'
            }
        ]
    }
]

const list = reactive(persons)

</script>
<template>
    <div>
        <ul>
            <li v-for="person in list">
                <span>{{person.name}}</span>
                <ul>
                    <li v-for="friend of person.friends">
                            <span>{{friend.name}}</span>
                    </li>
                </ul>
            </li>
        </ul>

    </div>
</template>

....................................................................................
                          Use Case 

Render collection 
When i click the item, we need to show the details 

eg:
  Todo item when i click todo item, show the full todo detail

<script setup>
import { reactive } from "vue";

const TODOS = [
     
    {
        userId: 1,
        id: 1,
        title: "delectus aut autem",
        completed: false
    },
    {
        userId: 1,
        id: 2,
        title: "quis ut nam facilis et officia qui",
        completed: false
    },
    {
        userId: 1,
        id: 3,
        title: "fugiat veniam minus",
        completed: false
    },
]

const todosList = reactive(TODOS);
const onSelectItem=()=>{
    console.log('item is selected')
}
</script>
<template>
  <div>
    <ul>
      <li v-for="todo in todosList" @click="onSelectItem">
     {{ todo.title }}
      </li>
    </ul>
  </div>
</template>
....................................................................................
				Lab
...................................................................................

1.You have to render list of Users from the array
  https://jsonplaceholder.typicode.com/users

Display field:
 UserName
2.When you click on Each user Name, you have to display the complete other user details
  
  1 details
  name:XXX
  email:XXX
    
  address:
    XXX
    geo
  phone
  website
  company
     XXXX

Here you have to create a separate Address Component,geo component, from the user component each user address must be passed as prop.
 
  <User>
    <Address>
     <Geo>
 </User>

.....................................................................................
.....................................................................................
				Array Mutations
.....................................................................................

Push,remove,update array elements

<script setup>
import { reactive } from 'vue';
const todos = reactive([])
//listener
const addItem = () => {
    todos.push({ id: Math.random(), text: 'Learn Vue!' })
}
</script>
<template>

    <ul>
        <li v-for="todo in todos">
            <span>{{todo}}</span>
        </li>
    </ul>
    <button @click="addItem">AddItem</button>
</template>
<style>

</style>

In vue all array apis will not trigger render cycle..

Api which trigger's render cycle - Mutating apis

1.push
2.pop
3.shift
4.unshift
5.splice
6.sort
7.reverse

Lab:
 Render List 
 
Sample

   item 1   - deleteItem (button)
   Item 2   - deleteITem (button) 

   Add Button

...................................................................................
			 Filtering/Sorting arrays with immutable api
...................................................................................

What is immutable api?

 when ever we do any changes on object, instead of changing original object changes, which creates a new copy of the object- immutable.

eg:
  if you add new item into array, the runtime will create new array,instead of mutating original memory.

Array immutable apis:
 map,filter,reduce - immutable apis
 or 
 you can use even spread operator or Object.assign method

<script setup>
import { ref } from "vue";
import TODOS from "./mock-data/Todos";
const todos = ref(TODOS);
const filter = () => {
  return todos.value= todos.value.filter((todo) => todo.completed);
};
</script>

<template>
  <div>
    <button @click="filter">FilterByStatus</button>
    <h1>Total todos: {{ todos.length }}</h1>
    <ul>
      <li v-for="todo in todos" :key="todo.id">
        <span>{{ todo.title }}</span>
      </li>
    </ul>
  </div>
</template>
.....................................................................................
				Computed Properties
..................................................................................

Computed properties are special methods which returns the template expressions.
If we use the expressions in a page more times, we can cache it.

Computed Properties in Options Api:
..................................

Without Computed Property method:
<script>
export default {
  data() {
    return {
      author: {
        name: "John Doe",
        books: ["Vue 2- Advanced Guide", "Vue 3- Basic Guide"],
      }
    };
  },
}
</script>
<template>
  <p>{{ author.name }} {{ author.books.length > 0 ? 'has' : 'has not' }} published books </p>
</template>

{{ author.books.length > 0 ? 'has' : 'has not' }} - This is expression

 if you include this calculation(expression) more than once in the template, it executes every time

Thats where computed properties  comes into picture

 <script>
export default {
    data() {
        return {
            author: {
                name: "John Doe",
                books: ["Vue 2- Advanced Guide", "Vue 3- Basic Guide"],
            }
        }
    },
    computed: {
        publishedBooksMessage() {
            console.log("called");
            // return this.author.books.length > 0 ? "Yes" : "No";
            return this.author.books.length > 0 ? 'has' : 'has not'
        },
    },
}
</script>
<template>
    <p>{{ author.name }} {{ publishedBooksMessage }} published books </p>
    <p>{{ author.name }} {{ publishedBooksMessage }} published books </p>

</template>

....................................................................................
			   Methods and Expressions

<script>
export default {
    data() {
        return {
            author: {
                name: "John Doe",
                books: ["Vue 2- Advanced Guide", "Vue 3- Basic Guide"],
            }
        }
    },
    methods: {
        calculateBooksMessage() {
            console.log("method called");
            return this.author.books.length > 0 ? 'has' : 'has not'
        }
    },
    computed: {
        publishedBooksMessage() {
            console.log("called");
            // return this.author.books.length > 0 ? "Yes" : "No";
            return this.author.books.length > 0 ? 'has' : 'has not'
        },
    },
}
</script>
<template>
    <p>{{ author.name }} {{ publishedBooksMessage }} published books </p>
    <p>{{ author.name }} {{ publishedBooksMessage }} published books </p>
    <br />
    <div>
        <h2>{{ calculateBooksMessage() }}</h2>
        <h2>{{ calculateBooksMessage() }}</h2>
    </div>
</template>


Now you can notice the same result by invoking a method in the expression which is defined inside methods or computed 

      "methods which are not cached but computed methods are cached"

....................................................................................
		Computed Properties and Composition api
.....................................................................................
<script setup>
import { reactive, computed } from "vue";

const author = reactive({
    name: "John Doe",
    books: ["Vue 2- Advanced Guide", "Vue 3- Basic Guide"],
});

const publishedMessage = computed(() => {
    return author.books.length > 0 ? "has" : "has not";
});
</script>
<template>
    <p>{{ author.name }} {{ publishedMessage }} published books </p>
</template>

Example Scenario
We'll create a simple Vue 3 app that shows a list of products with their prices and quantities. We'll use computed properties to calculate the total price of all items in the cart.

<template>
    <div>
      <h2>Shopping Cart</h2>
      <ul>
        <li v-for="product in products" :key="product.id">
          <span>{{ product.name }} - ${{ product.price }} x {{ product.quantity }}</span>
          <button @click="incrementQuantity(product.id)">+</button>
          <button @click="decrementQuantity(product.id)">-</button>
        </li>
      </ul>
      <h3>Total Price: ${{ totalPrice }} Total Items : {{totalQty}}</h3>
    </div>
  </template>
  
  <script setup>
  import { ref, computed } from 'vue';
  
  // Define products
  const products = ref([
    { id: 1, name: 'Apple', price: 1, quantity: 2 },
    { id: 2, name: 'Banana', price: 0.5, quantity: 3 },
    { id: 3, name: 'Orange', price: 0.8, quantity: 1 },
  ]);
  
  // Computed property to calculate total price
  const totalPrice = computed(() => {
    return products.value.reduce((total, product) => {
      return total + product.price * product.quantity;
    }, 0);
  });
  const totalQty = computed(() => {
    return products.value.reduce((total, product) => {
      return total + product.quantity 
    }, 0);
  });
  // Methods to change the quantity
  const incrementQuantity = (id) => {
    const product = products.value.find(p => p.id === id);
    if (product) {
      product.quantity++;
    }
  };
  
  const decrementQuantity = (id) => {
    const product = products.value.find(p => p.id === id);
    if (product && product.quantity > 0) {
      product.quantity--;
    }
  };
  </script>

  .....................................................................................
			  Data Sharing patterns
....................................................................................

1.Props or property pattern
  Sharing data from parent component to child component
2.Event Emitter pattern
  Sharing data from child to parent component
3.Global data sharing pattern

....................................................................................
			 Event Emitter pattern
...................................................................................

Child Component can emit event along with data, where as parent component can listen for data.

Event Emitter Syntax:


In the child component:

const emitter= defineEmits(['change','remove','save'])

emitter('NameoftheEvent',data)

emitter('onRequest',data)

In the Parent Component

<EventEmitterChild @on-request="getData"/>

function getData(evt){
  console.log(evt)
}

eg:

src/components/Child.vue
<script setup>
const emit = defineEmits(["onRequest"]);

const onSend = () => {
  //send data to parent
  emit("onRequest", "Hello,I am from Child");
};
</script>

<template>
  <div>
    <h1>Child Component</h1>
    <button @click="onSend">Send</button>
  </div>
</template>

Parent
src/App.vue
<!-- Parent Component -->
<script setup>
import { ref } from "vue";
import Child from "./components/Child.vue";

const data = ref("");
const getData = (evt) => {
  console.log(evt);
  data.value = evt;
};
</script>

.....................................................................................
			   Styling
.....................................................................................

CSS is key feature in every user interface design.

CSS can be integrated in vue js 

Types of styles

1.global style
2.component specific styles

1.global style is style which is intrdouced in main.js

import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')


2.How to integrate third css frameworks like bootstrap.

npm i bootstrap@5.3.3


<script setup>
</script>
<template>
  <div class="container py-4 px-3 mx-auto">
    <h1>Build Bootstrap with Vue</h1>
    <article>
      <p style="color:red">This is article</p>
    </article>
    <div class="card" style="width: 18rem">
      <img src="..." class="card-img-top" alt="..." />
      <div class="card-body">
        <h5 class="card-title">Card title</h5>
        <p class="card-text">
          Some quick example text to build on the card title and make up the bulk of the
          card's content.
        </p>
        <a href="#" class="btn btn-primary">Go somewhere</a>
      </div>
    </div>
    <div class="card" style="width: 18rem;">
  <img src="..." class="card-img-top" alt="...">
  <div class="card-body">
    <h5 class="card-title">Card title</h5>
    <p class="card-text">Some quick example text to build on the card title and make up the bulk of the card's content.</p>
    <a href="#" class="btn btn-primary">Go somewhere</a>
  </div>
</div>
  </div>
</template>
<style scoped></style>

https://bootstrap-vue.org
.....................................................................................
.....................................................................................
			      Component Speficic Styles
.....................................................................................
....................................................................................
			       Fall Through Attributes
	     (Sending HTML Attributes from the parent Component to Child Component)
.....................................................................................

Attribute inheritance:
......................

  A Fall through attribute is an attribute or v-on listeners that is passed to component but it is not explicitly declared in the receiving components(child components) via props or emits.  

  Properties which are inhierted from the parent component to child component 
  "class, style, and id attributes."

.....................................................................................
			      Component Speficic Styles
.....................................................................................
....................................................................................
			       Fall Through Attributes
	     (Sending HTML Attributes from the parent Component to Child Component)
.....................................................................................

Attribute inheritance:
......................

  A Fall through attribute is an attribute or v-on listeners that is passed to component but it is not explicitly declared in the receiving components(child components) via props or emits.  

  Properties which are inhierted from the parent component to child component 
  "class, style, and id attributes."

Parent: App.vue
<script setup>
import MyButton from "./components/MyButton.vue";
</script>
<template>
  <div class="container">
    <h1>Parent Component</h1>
    <!-- sending html attribute as prop: Fallthrough attributes -->
    <MyButton class="fancy-btn" />
    <br />
    <div style="margin:10px;10px;10px;10px">
      <button class="fancy-btn">Parent</button>
    </div>
  </div>
</template>
<style>
.fancy-btn {
  background-color: #4caf50;
  border: none;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline;
  font-size: 16px;
}
</style>


child:
src/components/MyButton.vue
<script setup></script>
<template>
   <button>Click</button>
</template>
<style></style>
.....................................................................................
....................................................................................
 How to access the attributes passed from parent in the child compoent

Two places:

1.inside template
2.inside script block

....................................................................................
 How to access the attributes passed from parent in the child compoent

Two places:

1.inside template
2.inside script block

using Options Api or setup
<script>
export default {
    created(){
        console.log(this.$attrs)
    }
}
</script>

using setup attribute 

<script setup>
import { useAttrs } from 'vue'
const attrs = useAttrs()
</script>

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button>{{props.title}}</button>
    <div>{{$attrs}}</div>
</template>
<style>

</style>
.................................................................................
		Can we override the dom attributes in the child component
...................................................................................
Yes possible except css properties by default

in the style we need add attribute in the style tag scoped

<script>
export default {
    created(){
        console.log(this.$attrs)
    }
}
</script>

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button>{{props.title}}</button>
     <!-- <div>{{$attrs}}</div> -->
</template>
<style scoped>
.fancy-btn {
    color:red
}
</style>
.....................................................................................
			Can we add new "class" to the component

yes,We can

When add new classes , the new css classes to be merged as part of old css.

<script>
export default {
    created(){
        console.log(this.$attrs)
    }
}
</script>
<script setup>
import { useAttrs } from "vue";
const attrs = useAttrs();

console.log(attrs.class);
</script>
<template>
  <button class="large">Click</button>
</template>
<style scoped>
.fancy-btn {
  color: red;
}
.large {
  font-family: "Gill Sans Extrabold", sans-serif;
  font-weight: bold;
}
</style>


output:
<button class="large fancy-btn" data-v-960f1381="">Click</button>
..................................................................................
			How to prevent Attribute inheritance
..................................................................................
yes we can.

<script>
export default {
  created() {
    console.log(this.$attrs);
  },
//   inheritAttrs: false,
};
</script>
<script setup>
import { useAttrs } from "vue";
const attrs = useAttrs();

console.log(attrs.class);
</script>
<template>
  <button class="large">Click</button>
</template>
<style scoped>
.fancy-btn {
  color: red;
}
.large {
  font-family: "Gill Sans Extrabold", sans-serif;
  font-weight: bold;
}
</style>
...................................................................................
...................................................................................
		 Dynamic css -Based on State if want to change the style
..................................................................................

<script setup>
import { ref } from "vue";
const isActive = ref(true);

const toggle = () => {
  isActive.value = !isActive.value;
};
</script>

<template>
  <!-- <div class="active">
    <h1>Hello</h1>
  </div> -->
  <div :class="{ active: isActive }">
    <h1>Hello</h1>
  </div>
  <button @click="toggle">Toggle</button>
</template>

<style scoped>
.active {
  color: blue;
}
</style>
....................................................................................
<script setup>
import { ref } from 'vue';

const isActive = ref(true)
const zoom = ref(true);

const toogle = () => {
    isActive.value = !isActive.value
    zoom.value = !zoom.value;
}
</script>
<template>
    <!-- Static Css -->
    <!-- <div class="active">
   <h1>Hello</h1>
</div> -->
    <!-- <div :class="{ active: isActive }">
        <h1>Hello</h1>
    </div> -->
    <div :class="{ active: isActive, zoom: zoom }">
        <h1>Hello</h1>
    </div>
    <button @click="toogle">Toggle</button>
</template>
<style scoped>
.active {
    color: blue
}

.zoom {
    font-size: 50px;
}
</style>
....................................................................................
....................................................................................
			Multiple styles in dynamic css


<script setup>
import { ref } from "vue";
const isActive = ref(true);
const zoom = ref(true);
const toggle = () => {
  isActive.value = !isActive.value;
  zoom.value = !zoom.value;
};
</script>

<template>
  <!-- <div class="active">
    <h1>Hello</h1>
  </div> -->
  <!-- <div :class="{ active: isActive }">
    <h1>Hello</h1>
  </div> -->
  <div :class="{ active: isActive, zoom: zoom }">
    <h1>Hello</h1>
  </div>
  <button @click="toggle">Toggle</button>
</template>

<style scoped>
.active {
  color: blue;
}
.zoom {
  font-size: 50px;
}
</style>
....................................................................................
			 dynamic "style" attribute

<script setup>
import { ref } from "vue";
const fontSize = ref(10);
const activeColor = ref("red");

const increment = () => {
  fontSize.value += 2;
};
</script>
<template>
  <!-- <div style="font-size:20px;">
     <h1>Hello</h1>
  </div> -->

  <div :style="{ 'font-size': fontSize + 'px', color: activeColor }">
    <h1>Hello</h1>
  </div>
  <button @click="increment">zoom</button>
</template>
<style></style>
.....................................................................................

Task:

Build Blog post app using css.

1.Prepare header
2.prepare body with card layout
3.prepare footer.
.....................................................................................
.....................................................................................
		 Slots- Component as Prop or DOM element as Prop
.....................................................................................

How to represent component inside template?

<MyComponent/> - self closing
  The component does not have any child

<MyComponent>
      You have to pass children
</MyComponent>

<Layout>
   <Header>
      <Logo/>
   </Header>
</Layout>

In order to access element/component as prop inside child component vue offers
built in component "slot" - Which is place holder where the elements to be inserted.

Use case: DOM element as Prop
..............................

Parent Component;

src/App.vue
<script setup>
import Child from './components/Child.vue'
</script>

<template>
  <Child>
    <!-- Passing dom element or other component as Child -->
    <h1>Hello</h1>
  </Child>
</template>
<style scoped>
</style>


Child Component

src/components/Child.vue
<script setup>
</script>

<template>
  <div>
      <slot></slot>
  </div>
</template>
<style scoped>
</style>


Use case : Component as Prop:
............................


Parent Component
src/App.vue
<script setup>
import Child from './components/Child.vue'
import Greeter from './components/Greeter.vue'
</script>
<template>
  <!-- Without passing any child -->
  <!-- <Child /> -->
  <Child>
    <!-- component as prop or any dom element as prop -->
    <h1>Hello</h1>
    <p>this is slot</p>
  </Child>

  <Child>
    <Greeter/>
  </Child>
</template>
<style scoped></style>

Child Components:
src/components/Greeter.vue
<script setup>
 
</script>
<template>
    <h1>Greeter</h1>
</template>

src/components/Child.vue
<script setup>
</script>

<template>
  <div>
      <slot></slot>
  </div>
</template>
<style scoped>
</style>

.....................................................................................
			 Fallback Content

From the parent if pass component/dom element as child, that dom element or component 
will be inserted, if you dont pass, then we can insert default dom element/component.

Parent:
src/App.vue
<script setup>
import Child from './components/Child.vue'
</script>

<template>
  <Child>
    <!-- Passing dom element or other component as Child -->
    <h1>Hello</h1>
  </Child>
  <Child/>
</template>
<style scoped>
</style>

Child 
src/components/Child.vue
<script setup>

</script>

<template>
  <h1>Child Component </h1>
  <div>
      <slot>
        <h1>Fallback</h1>
      </slot>
  </div>
</template>  
<style scoped>
</style>
.....................................................................................
			  Multi Slot
.....................................................................................

We can have more than one slot

Without slot:

<Layout>
  <Header/>
  <Body/>
  <Footer/>
</Layout>

With slot:

<Layout>
   <Header>
     
   </Header>
   <Body>
      
  </Body>
   <Footer>
     
   </Footer>
</Layout>

Syntax For multi slot:

Child Component
<slot name="header"></slot>

Parent Component:
<template v-slot:header>
  
</template>

.....................................................................................


src/components/Layout.vue
<script setup></script>

<template>
  <div>
    <slot name="header">
      <h1>Default Header</h1>
    </slot>
    <slot name="main">
      <p>This is default Main</p>
    </slot>
    <slot name="footer">
      <p>footer</p>
    </slot>
  </div>
</template>
<style scoped></style>

src/App.vue
<script setup>
import Layout from "./components/Layout.vue";
import Header from "./components/Header.vue";
import Logo from "./components/Logo.vue";
import Article from "./components/Articles.vue";
</script>

<template>
  <Layout>
    <template v-slot:header>
      <Header>
        <Logo />
      </Header>
    </template>
    <template v-slot:main>
      <Article />
    </template>
    <template v-slot:footer>
      <footer>
        <p>footer goest here</p>
      </footer>
    </template>
  </Layout>
</template>
<style scoped></style>
.....................................................................................
			Without Using v-slot,We can use #Name
....................................................................................

with v-slot directive
<template>
  <Layout>
    <template v-slot:header>
      <Header>
        <Logo />
      </Header>
    </template>
    <template v-slot:main>
      <Article />
    </template>
    <template v-slot:footer>
      <footer>
        <p>footer goest here</p>
      </footer>
    </template>
  </Layout>
</template>

without v-slot directive
<script setup>
import Layout from "./components/Layout.vue";
import Header from "./components/Header.vue";
import Logo from "./components/Logo.vue";
import Article from "./components/Articles.vue";
</script>

<template>
  <Layout>
    <template #header>
      <Header>
        <Logo />
      </Header>
    </template>
    <template #main>
      <Article />
    </template>
    <template #footer>
      <footer>
        <p>footer goes here</p>
      </footer>
    </template>
  </Layout>
</template>
<style scoped></style>
.....................................................................................
			 Default Slots
.....................................................................................

The slot without name is called "default Slot"

In Child Component:

    <slot name="header">
      <h1>Default Header</h1>
    </slot>
    <slot name="main">
      <p>This is default Main</p>
    </slot>
    <slot name="footer">
      <p>footer</p>
    </slot>

with Name
  <slot name="header">
      <h1>Default Header</h1>
    </slot>
without Name : Default slot
   <slot>
      <h1>Default Header</h1>
    </slot>

Note:
 Only one slot can be default slot

In the parent:

 <template #default>
 </template>

.....................................................................................
			 Default Slots
.....................................................................................

The slot without name is called "default Slot"

In Child Component:

    <slot name="header">
      <h1>Default Header</h1>
    </slot>
    <slot name="main">
      <p>This is default Main</p>
    </slot>
    <slot name="footer">
      <p>footer</p>
    </slot>

with Name
  <slot name="header">
      <h1>Default Header</h1>
    </slot>
without Name : Default slot
   <slot>
      <h1>Default Header</h1>
    </slot>

Note:
 Only one slot can be default slot

Parent Component:
src/App.vue
<script setup>
import Layout from "./components/Layout.vue";
import Header from "./components/Header.vue";
import Logo from "./components/Logo.vue";
import Article from "./components/Articles.vue";
</script>

<template>
  <Layout>
    <template #default>
      <Header>
        <Logo />
      </Header>
    </template>
    <template #main>
      <Article />
    </template>
    <template #footer>
      <footer>
        <p>footer goes here</p>
      </footer>
    </template>
  </Layout>
</template>
<style scoped></style>

Child Component:

src/components/Layout.vue
<script setup></script>

<template>
  <div>
    <slot>
      <h1>Default Header</h1>
    </slot>
    <slot name="main">
      <p>This is default Main</p>
    </slot>
    <slot name="footer">
      <p>footer</p>
    </slot>
  </div>
</template>
<style scoped></style>

.....................................................................................
			   Dyamic slots
.....................................................................................

The slot name can be dynamic

Static slot:

<template v-slot:header>
<template #header>

.....................................................................................
			   Dyamic slots
.....................................................................................

The slot name can be dynamic

Static slot:

<template v-slot:header>
<template #header>

Dynamic Slot:

<script setup>
import {ref} from 'vue'

import Layout from "./components/Layout.vue";
import Header from "./components/Header.vue";
import Logo from "./components/Logo.vue";
import Article from "./components/Articles.vue";

const main = ref('main')

</script>

<template>
  <Layout>
    <template #default>
      <Header>
        <Logo />
      </Header>
    </template>
    <template #[main]>
      <Article />
    </template>
    <template #footer>
      <footer>
        <p>footer goes here</p>
      </footer>
    </template>
  </Layout>
</template>
<style scoped></style>
			.....................................................................................
			Slot Scope
....................................................................................
Slot scope enables data accessability for parent and child components.

There are two slot scope

1.Render scope
2.scoped slots

Render Scope:
  Slot content has access to the data scope of the parent component, because it is defined in the parent component

<span>{{message}}</span>

<FancyButton>{{message}}</FancyButton>

Here both {{message}} interploations will render the same content.

Slot content does not have access the child component's data. Expressions in Vue templates can only access the scope it is defined in, consistent with js lexical scoping.

     Experessions in the parent template only have access to the parent scope;
		Expressions in the child template only have access in the 
			  child template only


	"As rule of thumb everthing in the template compiled in the parent scope;
	 "everthing is compiled in the child template in the child scope".




Scoped Slot:

    if you want to access data in the parent and child scope.

 "if parent component wants to access child state(data), the child component can pass data to the parent via "Slot" when rendering it".

    "Slot can act as bridge between parent and child for data transfer"


Child:
<slot :firstName="name" :age="age" />


eg
Child Component:
src/components/ScopeSlot.vue

<script setup>
import {ref} from 'vue'
const message = ref('hello')
</script>

<template>
 <slot :message="message"></slot>
</template>  
<style scoped>
</style>

src/App.vue
<script setup>
import ScopedSlot from './components/ScopeSlot.vue'
</script>

<template>
  <ScopedSlot v-slot="slotProps">
        {{slotProps.message}}
  </ScopedSlot>
</template>  
<style scoped>
</style>
		...................................................................................
			Dependency Injection:Composition API
....................................................................................

Prop Drilling:
..............
  When you pass data from the parent component to child, from child to its children and so on, at each level you have to pass props manually.

 			 Root
			  |
			 props
			  |
			 Child1
			   |
			 Props
                            |
			 Child 2
			   |
			  props
			 Child 3
			   |
			 props
			   |
			 Child N


Parent:
<script setup>
import { ref } from "vue";
import Child1 from "./components/Child1.vue";
const message = ref("hello");
</script>

<template>
  <Child1 :message="message" />
</template>

<style scoped></style>

Child Components

Child1
src/components/Child1.vue
<script setup>
import Child2 from './Child2.vue'
const props = defineProps(["message"]);

</script>

<template>
    <Child2 :message="props.message"/>
</template>

<style scoped></style>

Child2
src/components/Child2.vue

<script setup>
import Child3 from './Child3.vue'
const props = defineProps(["message"]);

</script>

<template>
    <Child3 :message="props.message"/>
</template>

<style scoped></style>


Child 3
src/components/Child3.vue
<script setup>
const props = defineProps(["message"]);

</script>

<template>
    <h1>{{props.message}}</h1>
</template>

<style scoped></style>

Parent:

src/<script setup>
import { ref, provide } from "vue";

import Child1 from "./components/Child1.vue";
const message = ref("hello");
provide("greeting", message);
</script>

<template>
  <Child1 :message="message" />
</template>

<style scoped></style>


Child 
src/components/Child3.vue
<script setup>
import { inject } from "vue";
const props = defineProps(["message"]);
const greeting = inject("greeting");
</script>

<template>
  <h1>{{ props.message }}</h1>
  <h1>From provider {{ greeting }}</h1>
</template>

<style scoped></style>

.....................................................................................
		 How to pass multiple properties via provide


Parent
src/App.vue
<script setup>
import { ref, provide } from "vue";

import Child1 from "./components/Child1.vue";
const message = ref("hello");
provide("greeting", message);
provide("welcome", "welcome");
</script>

<template>
  <Child1 :message="message" />
</template>

<style scoped></style>


src/components/Child3.vue
<script setup>
import { inject } from "vue";
const props = defineProps(["message"]);
const greeting = inject("greeting");
const welcome = inject("welcome")
</script>

<template>
  <h1>{{ props.message }}</h1>
  <h1>{{ greeting }} {{welcome}}</h1>
</template>

<style scoped></style>
.............................********................................................
.............................********................................................
			Default Value

What if i dont provide value?

inject("key","defaultValue")

src/components/Child3.vue

<script setup>
import { inject } from "vue";
const props = defineProps(["message"]);
const greeting = inject("greeting");
const welcome = inject("welcome","Default")
</script>

<template>
  <h1>{{ props.message }}</h1>
  <h1>{{ greeting }} {{welcome}}</h1>
</template>

<style scoped></style>
.....................................................................................
			Global Data sharing
		      (App Level Data Sharing)
....................................................................................

if you want to share data , across the application, using provide function we can 
with help of application object.

main.js
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App).provide('companyName','IBM').mount('#app')

src/components/Child3.vue
<script setup>
import { inject } from "vue";
const props = defineProps(["message"]);
const greeting = inject("greeting");
const welcome = inject("welcome", "Default");
const company = inject("companyName");
</script>

<template>
  <h1>{{ props.message }}</h1>
  <h1>{{ greeting }} {{ welcome }} {{company}}</h1>
</template>

<style scoped></style>

.....................................................................................
			 Component Life Cycles
.....................................................................................

<script setup>
import { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, ref } from "vue";

const counter = ref(0);

onBeforeMount(() => {
  console.log("onBeforeMount is called");
});

onMounted(() => {
  console.log("onMounted is called");
});

onBeforeUpdate(() => {
  console.log("onBeforeUpdate is called");
});
onUpdated(() => {
  console.log("OnUpdated is called")
})
</script>

<template>
  <h1>Life Cycles</h1>
  <button @click="counter++">{{ counter }}</button>
</template>
<style scoped></style>
.....................................................................................
			API Calls
.....................................................................................

1.You can write api calls within component
2.YOu can write api call outside component using "Composables"
3.You can write api call outside component using State management libs -Pina

Conditional Rendering:
Using v-if,v-else,v-if...v-else-if

<div v-if="condtion">
  this block of code to be executed
</div>
<div v-else>
  this block of code to be executed
</div>

else-if

<div v-if="condtion">
  this block of code to be executed
</div>
<div v-else-if="condition">
  this block of code to be executed
</div>
<div v-else>
  this block of code to be executed
</div>

When you make api call there is three conditions

1.data may be available on time.
2.data may come slowly
3.error may come

in order to make api call, in js we use "Ajax" libs..

Vue has no any opinion to use ajax lib, you can use any ajax lib.

There are many libs available but most popular are two

1.axios - third party lib
2.fetch - native browser lib/api

<script setup>
import { onMounted, reactive } from 'vue';
const state = reactive({
  data: null,
  error: null
})
async function fetchAlbums() {
  try {
    const url = 'https://jsonplaceholder.typicode.com/albums'
    const response = await fetch(url)
    const albums = await response.json()
    console.log(albums)
    state.data = albums
  }
  catch (err) {
    console.log(err)
    state.error = err
  }
}

onMounted(() => {
  //you have to write api call 
  fetchAlbums()
})
</script>
<template>
  <div>
    <div v-if="state.error">
      <h1>Opps! {{ state.error.message }}</h1>
    </div>
    <div v-else-if="state.data">
      <!-- show the data -->
      <div v-for="album of state.data">
        <h3>{{ album.title }}</h3>
      </div>
    </div>
    <div v-else>
      <!-- Show progress bar -->
      <h1>Loading...</h1>
    </div>
  </div>
</template>
<style scoped></style>
.....................................................................................
.....................................................................................
		How to isloate the ajax logic using composables
.....................................................................................
What is a "Composable"?

In the context of Vue applications, a "composable" is a function that leverages Vue's Composition API to encapsulate and reuse stateful logic.

When building frontend applications, we often need to reuse logic for common tasks. For example, we may need to format dates in many places, so we extract a reusable function for that. 

This formatter function encapsulates stateless logic: it takes some input and immediately returns expected output. There are many libraries out there for reusing stateless logic

Mouse Tracker Example:

 i want to track the mouse x and y location across the application


Use case: Mouse Tracking feature within component


<script setup>
import { onMounted, onUnmounted, ref } from 'vue';
const x = ref(0)
const y = ref(0)

function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}

onMounted(() => {
  window.addEventListener('mousemove', update)
})
onUnmounted(() => {
  window.removeEventListener('mousemove', update)
})
</script>
<template>
  <div>
    <h1>X:{{ x }} Y: {{ y }}</h1>
  </div>
</template>

What if i want to resue the same logic in multiple components? we can extract the logic into an external file which is called composable function
..............

src/composables/useMouse.js
import { onMounted, onUnmounted, ref } from 'vue';

function useMouse() {
    const x = ref(0)
    const y = ref(0)

    function update(event) {
        x.value = event.pageX
        y.value = event.pageY
    }
    onMounted(() => {
        window.addEventListener('mousemove', update)
    })
    onUnmounted(() => {
        window.removeEventListener('mousemove', update)
    })
    //return composable values;it can be variables,functions,objects
    return {
        x,
        y
    }
}
export { useMouse }

src/App.vue
<script setup>
import { useMouse } from './composables/useMouse';
const { x, y } = useMouse()
</script>
<template>
    <div>
        <h1>X:{{ x }} Y: {{ y }}</h1>
    </div>
</template>
.....................................................................................
		Breaking into composables into another composables


From the above example we can isloate listener coe into another composables


src/composable/useEvent.js

import { onMounted,  onUnmounted } from "vue";

export function useEventListener(target, event, callback) {
    onMounted(() => {
        target.addEventListener(event, callback)
    })
    onUnmounted(() => {
        target.removeEventListener(event, callback)
    })
}
src/composables/useMouse.js
import {ref } from 'vue';
import { useEventListener } from './useEvent';

function useMouse() {
    const x = ref(0)
    const y = ref(0)
    useEventListener(window, 'mousemove', (event) => {
        x.value = event.pageX
        y.value = event.pageY
    })
    //return composable values;it can be variables,functions,objects
    return {
        x,
        y
    }
}
export { useMouse }
.....................................................................................
			API Calls and composables
....................................................................................

src/composables/useFetch.js
import { onMounted, ref } from "vue";

function useFetch(url) {
    const data = ref(null)
    const error = ref(null)
    //write function to fecth data
    async function fetchAlbums() {
        try {
            const response = await fetch(url);
            const albums = await response.json();
            data.value = albums;
        } catch (err) {
            console.log(err);
            error.value = err;
        }
    }

    //api calls must be done inside onmount
    onMounted(() => {
        fetchAlbums();
    });
    return {
        data, error
    }
}

export { useFetch }

src/App.vue
<script setup>
import { useFetch } from "./composables/useFetch";
const url = "https://jsonplaceholder.typicode.com/albums";
const { data, error } = useFetch(url);

</script>
<template>
    <div>
        <h1>Albums</h1>
        <div v-if="error">
            <h1>Oops! {{ error.message }}</h1>
        </div>
        <div v-else-if="data">
            <div v-for="album of data">
                <h3>{{ album.title }}</h3>
            </div>
        </div>
        <div v-else>
            <h1>Loading....</h1>
        </div>
    </div>
</template>

<style scoped></style>
....................................................................................				Third party composables

https://vueuse.org/

You can thrid party composable utilities in this web site.
...................................................................................
				                 Watchers
...................................................................................

What is Watcher?
   Watcher is a function, which allows us to monitor an application state and trigger actions based on these changes.
   Watchers that allows us to observe some data and perform specific actions when it changes.
   It is more generic way to observe and react to data changes in the vue instance.

 With watchers, we are not just able to watch a property and perform custom actions, we can also access the old value that is particular property is changing from, as well as the new value that it has changed to.

Watchers in Options api:
<script>
export default {
    data() {
        return {
            counter: 0
        }
    },
    watch: {
        counter(newValue, oldValue) {
            console.log('oldValue=>', oldValue, 'newValue=>', newValue)
        }
    }
}
</script>
<template>
    <h1>Counter {{counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>

....................................................................................
			Watchers in Composition Api using Setup function
.....................................................................................
<script>
import { ref, watch } from 'vue';

export default {
    setup() {
        const counter = ref(0)
        //watchers
        watch(counter, (newValue, oldValue) => {
            console.log('oldValue=>', oldValue, 'newValue=>', newValue)
        })

        return {
            counter
        }
    }
}
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>

....................................................................................
		Watchers in Composition Api using Setup attribute
.....................................................................................
<script setup>
import { ref, watch } from 'vue';
const counter = ref(0)
//watchers
watch(counter, (newValue, oldValue) => {
    console.log('oldValue=>', oldValue, 'newValue=>', newValue)
})
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>
....................................................................................
			 Object Properties and Watchers
....................................................................................
Watchers will trigger only when data is changed, meaning once the user starts interact or if any changes are deducted.

we may want to perform certain actions with initial value of the property we are watching for our app might require that we send an API request with inital data and then repeat the process if the data changes.

watch(comments, (newValue, oldValue) => {
    console.log('oldValue=>', oldValue)
    console.log('newValue=>', newValue)
 }, {
    // deep: true
    immediate: true
})


<script setup>
import { reactive, watch } from 'vue';

const comments = reactive({
    like: 0, dislike: 0, recommend: {
        rating: {
            value: 0
        }
    }
})
//watchers which watches all properties including ensted property
// watch(comments, (newValue, oldValue) => {
//     console.log('oldValue=>', oldValue, 'newValue=>', newValue)
//     console.log('old value=>', oldValue.recommend.rating.value)
//     console.log('new value=>', newValue.recommend.rating.value)

// })
//watchers which watches disable inner property changes

watch(comments, (newValue, oldValue) => {
    console.log('oldValue=>', oldValue)
    console.log('newValue=>', newValue)
  
}, {
    // deep: true
    immediate: true
})
</script>
<template>
    <h1>Reactive State with Watchers</h1>
    <h1>Like : {{ comments.like }} Dislike {{ comments.dislike }} Rating Value {{ comments.recommend.rating.value }}</h1>
    <button @click="comments.like++">Like</button>
    <button @click="comments.dislike++">Dislike</button>
    <button @click="comments.recommend.rating.value++">Rating</button>
</template>
<style></style>
....................................................................................
....................................................................................
			watch is simpilifed with "watchEffect" api
.....................................................................................
<script setup>
import { ref, watch, watchEffect } from 'vue';

const counter = ref(0)
// //watchers
// watch(counter, (newValue, oldValue) => {
//     console.log('oldValue=>', oldValue, 'newValue=>', newValue)
// })
watchEffect(() => {
    console.log('Watcher => ', counter.value)
})
</script>
<template>
    <h1>Counter {{ counter }}</h1>
    <button @click="counter++">+</button>
</template>
<style></style>

....................................................................................
			 Watchers in Real time
...................................................................................

Real time conversion
Real data fetch.....

<script setup>
import { ref, watch } from 'vue';

const tmpCelsius = ref(0)
const tmpFarenheit = ref(0)

watch(tmpCelsius, newValue => {
    tmpFarenheit.value = Math.round((newValue * 9) / 5 + 32)
})

</script>
<template>
    <h1>TmpCelsius: {{tmpCelsius}} TmpFarenheit {{ tmpFarenheit }}</h1>
    <button @click="tmpCelsius+=3">TmpFarenheit</button>
</template>
<style></style>
	
.....................................................................................
				Custom Directives
.....................................................................................

Code Reuse in Vue:

The application code can be reused in vue in various ways.

1.Composables
   Way to reuse app state logic
2.Components
   Way to resue UI 
3.Directives 
   Way to resue underlaying dom features


There are different types of directives 

1.built in directives
   Directives are provided by vue - v-on,v-bind....
2.custom directives


How to create simple custom Directive?

Directive is object, having low level dom features.

Steps:

1.create directive object as part of any component.

<script setup>
//first directive
const vFocus = {
  //define life cycle method
  mounted: (element) => {
   
  },
}
</script>
<template>
  
</template>

2.Attach directive on html element

<script setup>
//first directive vBind,vIf -  v-bind , v-if
const vFocus = {
  //define life cycle method
  mounted: (element) => {
    console.log('vFocus directive')
    console.log(element)
    element.focus()
  },
}
</script>
<template>
  <input v-focus />
</template>
.....................................................................................
			  More dom maniuplation
....................................................................................
<script setup>
const VHighlight = {
    mounted: (element) => {
        //add event listener
        element.addEventListener('mousemove', (evt) => {
            //  element.style.backgroundColor = 'yellow'
            highLight('yellow')
        })
        element.addEventListener('mouseleave', (evt) => {
            //element.style.backgroundColor = null
            highLight(null)
        })
        const highLight = (color) => {
            element.style.backgroundColor = color
        }
    }
}
</script>
<template>
    <h1 v-highlight>Touch Me</h1>
</template>

Directive Hooks:
  Directive hooks are methods which are called in every life cycle of directive

created(element,binding,vnode,prevNode)

beforeMount () - called before the target element is inserted into dom

mounted() -> called before the parent component is updated

beforeUpdate()- called after the parent component and all of its childern have updated

update() -called after beforeUpdate

beforeUnmount() - before removing element

unmounted()  - when component is unmounted.


How to create global directives
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'HCL')
    .directive('focus', (element, binding) => {
        element.focus()
    })
    .directive('highlight', (element, binding) => {
        element.addEventListener('mousemove', (evt) => {
            //  element.style.backgroundColor = 'yellow'
            highLight('yellow')
        })
        element.addEventListener('mouseleave', (evt) => {
            //element.style.backgroundColor = null
            highLight(null)
        })
        const highLight = (color) => {
            element.style.backgroundColor = color
        }
    })
    .mount('#app')

How to use?
src/App.vue
<script setup>
</script>
<template>
    <input v-focus/>
    <div v-highlight>TouchMe</div>
</template>

How to pass parameter to directive?

<input v-bind:value="msg"/>				
  
// import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'

createApp(App)
    .provide('company', 'HCL')
    .directive('focus', (element, binding) => {
        element.focus()
    })
    .directive('highlight', (element, binding) => {
        //reading parameter passed by element using binding
        console.log(binding)
        //set the inital color
        element.style.backgroundColor = binding.value 
        element.addEventListener('mousemove', (evt) => {
            //  element.style.backgroundColor = 'yellow'
            highLight('yellow')
        })
        element.addEventListener('mouseleave', (evt) => {
            //element.style.backgroundColor = null
            highLight(null)
        })
        const highLight = (color) => {
            element.style.backgroundColor = color
        }
    })
    .mount('#app')

<script setup>
import { ref } from 'vue';

const color = ref('green')
</script>
<template>
    <input v-focus/>
    <div v-highlight.value="color">TouchMe</div>
</template>
....................................................................................
			Handling Forms
...................................................................................

Form Controls:
1.text / password
2.Multi line text
3.checkbox
4.radio
5.select

How to get input from the keyboard via form controls and bind in the ui

Syntax:

<input @input="listener" >

<script setup>
import { ref } from 'vue';
const name = ref('defaultName')
const getInput = (evt) => {
  name.value = evt.target.value
}
</script>
<template>
  <h1>{{name}}</h1>
  <input @input="getInput" />
</template>


Two way data binding:

When ever user interacts via typing in the text box, the reactive variable is updated,when ever reactive variable is updated, the UI is rerendered.

:value
  property  is used to initalize the default reactive state variable in side text box

<script setup>
import { ref } from 'vue';
const name = ref('defaultName')
const getInput = (evt) => {
  name.value = evt.target.value
}
</script>
<template>
  <h1>{{name}}</h1>
  <input @input="getInput"  :value="name"/>
</template>

.....................................................................................
				How to reduce listeners
.....................................................................................

When we have more input fields, we need to write more event listeners, which can be avoided in two ways


1.inline event listener
<script setup>
import { ref } from 'vue';
const name = ref('defaultName')
</script>
<template>
    <h1>{{ name }}</h1>
    <input @input="event => name = event.target.value" :value="name" />
</template>

2.Using v-model directive
->It removes explicit event binding ,which attaches the default event handler and event automatically.

<script setup>
import { ref } from 'vue';
const name = ref('defaultName')
</script>
<template>
    <h1>{{ name }}</h1>
    <input v-model="name" />
</template>

v-model directive can be used on other input controls as well.

textarea
  it uses value property and input event
checkbox
radio
  It uses checked property and change event
select
 It uses value property and input event 

TextArea:
..........

Using Text area , we can get multi line input
<script setup>
import { ref } from 'vue';
const mail = ref('')
</script>
<template>
    <div>
        <h2>{{ mail }}</h2>
        <label id="mail">Mail</label>
        <textarea v-model="mail" />
    </div>
</template>

Checkbox 

Single Checkbox:
<script setup>
import { ref } from 'vue';
const checked = ref(true)

</script>
<template>
    <div>
        <input type="checkbox" id="checkbox" v-model="checked" />
        <label for="checkbox">{{checked}}</label>
    </div>
</template>

Multi Checkbox value collection:
...............................

<script setup>
import { ref } from 'vue';

const values = ref([])

</script>
<template>
    <div>
        <h1>Course Information</h1>

        <input type="checkbox" id="frontend" value="frontEnd" v-model="values" />
        <label for="frontend">Front End</label>
        <input type="checkbox" id="backend" value="BackEnd" v-model="values" />
        <label for="backend">Back End</label>
        <input type="checkbox" id="devops" value="Dev Ops" v-model="values" />
        <label for="devoops">Dev Ops</label>
    </div>
    <div>
        {{ values }}
    </div>
</template>

....................................................................................
Radio Button:
............
<script setup>
import { ref, computed } from 'vue';

const choice = ref("Male")


</script>
<template>
    <div>
        <h1>Select any One</h1>
        <input type="radio" id="Male" value="Male" checked v-model="choice" />
        <label for="Male">Male</label>
        <input type="radio" id="Female" value="Female" v-model="choice" />
        <label for="Female">FeMale</label>
    </div>
    <div>
        {{ choice }}
    </div>
</template>
.................................................................................

.................................................................................

Select:
<script setup>
import { ref, computed } from 'vue';

const selected = ref('')
const courses = ref(["Vue", "React", "Angular", "MicroServices"])
const selectedCourse = ref('')
</script>
<template>
    <div>
        <select v-model="selected">
            <option disabled value>Select Your choice</option>
            <option>Vue</option>
            <option>React</option>
            <option>Angular</option>
            <option>MicroServices</option>
        </select>
    </div>
    <div>
        {{ selected }}
    </div>
    <hr />
    <div>
        <select v-model="selectedCourse">
            <option disabled value>Select Your choice</option>
            <option v-for="course of courses">{{ course }}</option>
        </select>
    </div>
    <div>
        {{ selectedCourse }}
    </div>
</template>

.................................................................................
.................................................................................
Value Bindings -vue custom attributes:
....................................

v-model=""
true-value="yes" //replace true or false value into meaningfull values 
false-value="no"

<script setup>
import { ref } from 'vue';
const toggle = ref(true)
const truthyValue="Yes"
</script>
<template>
    <div>
        <input type="checkbox" :true-value="truthyValue" checked false-value="no" v-model="toggle" />
        <label for="Toggle">Toggle</label>
    </div>
    <div>
        <!-- {{toggle ? "Yes" : "No"}} -->
        {{ toggle }}
    </div>
</template>

For Radio button

:true-value=""

For Select options

:value="{text: 'some text'}"

....................................................................................
				Modifiers

if you want to change v-model behaviour, we can use modifiers

<input v-model="variable">
  Here Vue fires input event for every keystroke.
What if i want to add "change" event instead of input event

<input v-model.lazy="variable">
                |
       fires change event

Modifiers:

v-model.lazy -  fires change event
v-model.number -  converts strings into number
v-model.trim -  trims the leading strings

<script setup>
import { ref } from 'vue';
const name = ref('')
const price = ref("10")
const mailid =ref('admin@foo.com')

</script>
<template>
    <div>
        <!-- <input v-model="name" />  -->
        
        <!-- Fire Change Event : once if the textbox looses its focus -->
        <label for="Name">Name</label>
        <input id="Name" v-model.lazy="name" /> 

    </div>
        <div>
        
        <label for="Price">Price</label>
        <input id="Price" v-model.number="price" /> 

    </div>
      <div>
        
        <label for="mailId">mailId</label>
        <input id="mailId" v-model.trim="mailid" /> 

    </div>
    <div>
        <h1>{{ name }}</h1>
        <h1>Price {{price}} Total Price {{price * 2}}</h1>
        <h1>{{mailid}}</h1>
    </div>
</template>

....................................................................................
		Form Submission and How to prevent default events
......................................................................................

In java script, when you submit form, automatically there is event is fired , which is called "onSubmit" event.

onSubmit event by default looks the server url to be posted.
      <form action="http://www.google.com">
          <button>Submit</button>
      </form>

Here , the button tries to redirecto url mentioned in the action property.

I need to control, the form submission manually.

Event Object :

has api called "preventDefault()" , which does not trigger auto form submission.


<script setup>

const onSubmit = event => {
    if (event) {
        event.preventDefault();
    }
}

</script>
<template>
    <div>
        <form action="http://www.google.com">
            <button @click="onSubmit">Submit</button>
        </form>
    </div>
</template>

Vue has some short cuts, instead of giving this inside listener, we can give inside templates.

Event Modifiers:
...............

Event Modifiers are used with v-on

<form @submit.prevent="onSubmit">

<script setup>

const onSubmit = event => {
    alert('Form to be Submitted')
}

</script>
<template>
    <div>
        <form @submit.prevent="onSubmit">
            <button>Submit</button>
        </form>
    </div>
</template>


Other event modifiers

//event propagation to be stopped
<a @click.stop="listner">

I want to submit form when key board events

<input @keyup.enter="onSubmit">

other keyboard keys modifiers

.enter
.tab
.left
.right
.space
.down
.up

.ctrl
.alt
.shift
.meta
.enter
.....................................................................................
				Form Validation
.....................................................................................
Without using libs:

<template>
    <form @submit.prevent="submitForm">
      <div>
        <label for="username">Username</label>
        <input v-model="form.username" id="username" name="username" @input="validateUsername" />
        <span v-if="errors.username">{{ errors.username }}</span>
      </div>
  
      <div>
        <label for="email">Email</label>
        <input v-model="form.email" id="email" name="email" type="email" @input="validateEmail" />
        <span v-if="errors.email">{{ errors.email }}</span>
      </div>
  
      <button type="submit" :disabled="!isValid">Submit</button>
    </form>
  </template>
  
  <script setup>
  import { reactive, computed } from 'vue';
  
  // Reactive state for form fields
  const form = reactive({
    username: '',
    email: '',
  });
  
  // Reactive state for errors
  const errors = reactive({
    username: '',
    email: '',
  });
  
  // Validation functions
  const validateUsername = () => {
    errors.username = form.username.length < 3 ? 'Username must be at least 3 characters long' : '';
  };
  
  const validateEmail = () => {
    const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    errors.email = !emailPattern.test(form.email) ? 'Invalid email address' : '';
  };
  
  // Computed property to check if the form is valid
  const isValid = computed(() => !errors.username && !errors.email);
  
  // Form submit handler
  const submitForm = () => {
    validateUsername();
    validateEmail();
    if (isValid.value) {
      alert(`Form Submitted: ${JSON.stringify(form)}`);
    }
  };
  </script>
  
  <style scoped>
  form div {
    margin-bottom: 10px;
  }
  
  label {
    display: block;
    margin-bottom: 5px;
  }
  
  input {
    display: block;
    padding: 8px;
    width: 100%;
    margin-bottom: 5px;
  }
  
  span {
    color: red;
  }
  
  button {
    padding: 10px 15px;
    background-color: blue;
    color: white;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  
  button:disabled {
    background-color: gray;
    cursor: not-allowed;
  }
  </style>
  

Using third party libs:

npm install vee-validate yup

<template>
    <form @submit.prevent="submitForm">
        <div>
            <label for="username">Username</label>
            <input v-model="username" id="username" name="username" @blur="validateUsername" />
            <span>{{ errors.username }}</span>
        </div>

        <div>
            <label for="email">Email</label>
            <input v-model="email" id="email" name="email" type="email" @blur="validateEmail" />
            <span>{{ errors.email }}</span>
        </div>

        <button type="submit" :disabled="!isValid">Submit</button>
    </form>
</template>

<script setup>
import { ref, reactive, computed } from 'vue';
import { useField, useForm } from 'vee-validate';
import * as yup from 'yup';

// Define the validation schema
const schema = yup.object({
    username: yup.string().required('Username is required'),
    email: yup.string().email('Email must be valid').required('Email is required'),
});

// Form state and validation
const { handleSubmit, errors } = useForm({
    validationSchema: schema,
});

const { value: username, errorMessage: usernameError, validate: validateUsername } = useField('username');
const { value: email, errorMessage: emailError, validate: validateEmail } = useField('email');

const isValid = computed(() => !usernameError.value && !emailError.value);

// Form submit handler
const submitForm = handleSubmit(values => {
    alert(`Form Submitted: ${JSON.stringify(values)}`);
});
</script>

<style scoped>
form div {
    margin-bottom: 10px;
}

label {
    display: block;
    margin-bottom: 5px;
}

input {
    display: block;
    padding: 8px;
    width: 100%;
    margin-bottom: 5px;
}

span {
    color: red;
}

button {
    padding: 10px 15px;
    background-color: blue;
    color: white;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s;
}

button:disabled {
    background-color: gray;
    cursor: not-allowed;
}
</style>
	.....................................................................................
			  Template Ref
....................................................................................
		
How to access dom element in Vue?
 Inside component : event object
 Inside Template  : ref keyword.

syntax:
 <input ref="variable">

ref is attribute is used to access dom element or child component instance after it is mounted.

ref ,can be used inside "onMounted" life cycle api.

Use cases:
1.in order to access dom elements directly
2.in order to integrate third party libs.

<script setup>
import { onMounted, ref } from 'vue';
const myinput = ref(null)
onMounted(()=>{
   // console.log(myinput.value)
   myinput.value.focus()
})
</script>
<template>
    <input ref="myinput" />
</template>


.....................................................................................
			Plugins
.....................................................................................
What is plugin?

 Plugins are self contained code that usuallay add app-top level functionality to Vue.
Most of third party libs are integrated as plugin with vue echo system eg: Vue-router
Statement management libs like vuex,Pinia.

Plugins are distribtued as npm modules, in order to use plugins, we have to do two things

1.install plugin as npm module

 npm install pluginPackage

2.Integrate Plugin with application Object

const app = createApp(App)

app.components()
app.provide()

//plugin
app.use(MyPlugin)
app.use(router)
app.use(pina)

How to write custom plugin?

export const myPlugin = {
    install(app, options) {
        //application object referenced in the plugin as first parameter
        app.config.globalProperties.$uppercase = key => {
            return key.toUpperCase()
        }
    }
}

Step 2: register the plugin in application object

import './assets/main.css'

import { createApp } from 'vue'
import App from './App.vue'
import { myPlugin } from './plugins/myPlugin'

const app = createApp(App)
app.use(myPlugin)
app.mount('#app')

Step 3: Use the plugin functionality inside app

<script setup>

</script>
<template>
  <h1>{{ $uppercase('hello, how are') }}</h1>
</template>
.....................................................................................
			State Management Libs - Pinia
....................................................................................

What is Pinia?
 State management lib for managing state and its life cycle of vue application.

Pinia is written for "Vue 3 Composition API model and Composable Style",unlike VueX which is another statemanagement lib for vue 2, which is written imperative style.

Pinia can work with any versions,mostly recommended for vue 3 projects.

Pinia Core Concepts:

1.State
2.Store
3.Actions
4.Getters

State:
  It represents the application data
  Which is centeral part of app/store

Store:
  Object which encapsulate component's (state,actions (computed), the state inside store is reactive

Actions:
 Object which encapsulate components behaviour(methods)

Getters:
 Object which encapsulate components computed Properties

Store = {state + actions + getters}


Pinia is distributed as plugin in vue echo system...so we need to install pinia and we have integrate with application object

npm i pinia

main.js

 createApp(App).use(createPinia())

When you create project itself you can integrate pinia.


G:\HCL>npm init vue@latest

> npx
> create-vue


Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-pinia
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes - Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add an End-to-End Testing Solution? » No
√ Add ESLint for code quality? » No

Scaffolding project in G:\HCL\vue-pinia...

Done. Now run:

  cd vue-pinia
  npm install
  npm run dev

.....................................................................................

Use case: State mutation with in component

<script setup>
import { ref } from "vue";
const counter = ref(0)
</script>
<template>
  <div>
    <h1>Counter : {{ counter }}</h1>
    <button @click="counter++">+</button>
  </div>
</template>

Use case: State Mutation outiside component using Pinia


steps:
1.create store
src/stores/counter.js

Options Api Style:
1.1.State Declaration
import { defineStore } from "pinia"

const useCounterStore = defineStore('counter', {
    //state declaration
    state: () => {
        //return reactive state
        return {
            counter: 0
        }
    }
});


export { useCounterStore }

1.2. Bind State in UI

<script setup>
import { useCounterStore } from './stores/counter.js'
const counter = useCounterStore()
</script>
<template>
    <div>
        <h1>Counter : {{counter.count}}</h1>
    </div>
</template>

2.Add biz logic : actions
import { defineStore } from "pinia"

const useCounterStore = defineStore('counter', {
    //state declaration
    state: () => {
        //return reactive state
        return {
            count: 0
        }
    },
    actions: {
        increment() {
            this.count++
        }
    }
});


export { useCounterStore }

2.1.Invoke biz logic from the UI
<script setup>
import { useCounterStore } from './stores/counter.js'
const counter = useCounterStore()
</script>
<template>
    <div>
        <h1>Counter : {{ counter.count }}</h1>
        <button @click="counter.increment">+</button>
    </div>
</template>

...................................................................................
			  Getters - computed Properties
....................................................................................

import { defineStore } from "pinia"

const useCounterStore = defineStore('counter', {
    //state declaration
    state: () => {
        //return reactive state
        return {
            count: 0
        }
    },
    actions: {
        increment() {
            this.count++
        }
    },
    getters: {
        doubleIt: state => state.count * 2
    }
});


export { useCounterStore }

<script setup>
import { useCounterStore } from './stores/counter.js'
const counter = useCounterStore()
</script>
<template>
    <div>
        <h1>Counter : {{ counter.count }} Double Counter: {{ counter.doubleIt }}</h1>
        <button @click="counter.increment">+</button>
    </div>
</template>
....................................................................................
			API calls and Pinia
////////////////////////////////////////////////////////////////////////////////////

import { defineStore } from "pinia";

export const useTodosStore = defineStore('todos', {
    state: () => {
        return {
            todos: [],
            error: null
        }
    },
    actions: {
        //async 
        async fetchTodos() {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos')
                const todos = await response.json()
                this.todos = todos
            }
            catch (err) {
                this.error = err
            }
        }
    },
    getters: {
        todosList: state => state.todos
    }

})

import { defineStore } from "pinia";

export const useTodosStore = defineStore('todos', {
    state: () => {
        return {
            todos: [],
            error: null
        }
    },
    actions: {
        //async 
        async fetchTodos() {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/todos')
                const todos = await response.json()
                this.todos = todos
            }
            catch (err) {
                this.error = err
                console.log(err)
            }
        }
    },
    getters: {
        todosList: state => state.todos
    }

})
...................................................................................
			Composition API
...................................................................................

import { defineStore } from "pinia";
import { ref } from 'vue'
//composition api
export const useCounterStore = defineStore('counter', () => {
    //state declaration
    const count = ref(0)
    //biz logic 
    function increment() {
        count.value++
    }
    function decrement() {
        count.value--
    }
    //computed properties
    const doubleIt = computed(() => count.value * 2)

    //return all 
    return {
        count, doubleIt, increment, decrement
    }


})
<script setup>
import { useCounterStore } from "./stores/counter.js";
const counterStore = useCounterStore()
</script>

<template>
 <h1>Counter App Using Pinia</h1>
 <h3>Value : {{counterStore.count}} {{counterStore.doubleIt}}</h3>
 <button @click="counterStore.increment">+</button>
</template>

<style scoped></style>

Task:
Convert API CALLS using composition Api
................................................................................
									SPA - Single Page Web Application
.................................................................................
SPA is type of web application built for browsers, which was introduced in 2017 as part of HTML 5 spec.
SPA is called client routing.

SPA core features:
1.All navigation is controlled inside browser only.
2.From the server we get only data via apis as json format
3.In SPA , Only we have one physical page index.html
4.Rest of the application page are called "virtual pages" which are created by js dynamically we call "components"
5.Navigation is controlled by js objects called "location and history" objects

Routing can be implemented using plain js,html 5,ajax, css3 itself , in large scale we need framework which is called "Vue Router"

Vue Router is framework which is supplied as plugin.

Setup project with router is included

project structure

App
  |
  src
   |
   components
   stores
   views
   router
 App.vue
 main.js

components
views
  both are going to hold components

view is special component which is going act as place holder component 
view component is going to display just page which can hold other components
for eg. when we click product menu, we display product page, where product page is view component, inside product page we display product details.

router
  which has a file which configures menus and mapping view components

...............................................................................
					              URL Pattern in SPA
..............................................................................

Types of url
1.static web url
  http://www.example.com/products.html / products.pdf

2.dynamic web url
  htttp://www.example.com/product.aspx or produdct.php, or product.jsp

3.Web service
    htttp://www.example.com/api/products => json 

4.SPA Web url
   htttp://www.example.com/index.html#products
      -hashbang notation
   htttp://www.example.com/products
      -webservice notation

webservice notation is easy and preferable way of implementation.


Steps:
 router/index.js

in order to create webservice notation: createWebHistory function is used
in order to create hashbang notation : createWebHashHistory function is used


import AboutView from "@/views/AboutView.vue";
import HomeView from "@/views/HomeView.vue";
import { createRouter, createWebHistory } from "vue-router";

//it defines the menu (url) configuration against "View-page"
const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
    component: AboutView
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: routes
})

export default router;
...............................................................................
             Master Page/Landing page menu Configuration
.............................................................................

We have to  define hyper links.

 App Component is root component or landing component which has master page details like links.

Vue-Router offers lot of built in components

1.RouterLink
    Used to define link
2.RouterView
    It is place holder component to display page.

src/App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
</script>
<template>
  <header>
    <h1>Site Header</h1>
    <!-- Menu Bar -->
    <nav>
      <ul>
        <li>
          <RouterLink to="/">Home</RouterLink>
        </li>
        <li>
          <RouterLink to="/about">About</RouterLink>
        </li>
      </ul>

    </nav>
  </header>
  <!-- Body section to display menu content -->
  <RouterView></RouterView>
  <footer>
    <p>Footer</p>
  </footer>
</template>
.................................................................................
Adding Feature:

Steps:
1.you can add menu
   <li>
          <RouterLink to="/review">Review</RouterLink>
        </li>
2.Create View Component

src/views/ReviewView.vue
<script setup>
</script>
<template>
  <h1>Home View</h1>
</template>

3.create application components 
src/components/revies/Review.vue

<script setup>
</script>
<template>
  
</template>

4.Add  biz logic

src/stores/counter.js
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }

  return { count, doubleCount, increment }
})

5.src/compoentes/reviews/Review.vue
<script setup>
import { useCounterStore } from './stores/counter'
const counterStore = useCounterStore()
</script>
<template>
    <div>
        <h1>Review</h1>
        <h1>Like {{ counterStore.count }}</h1>
    </div>
</template>

6.Refer the Review Component inside ReviewView
src/views/ReviewView.vue
<script setup>
import Review from './components/reviews/Review.vue'
</script>
<template>
    <Review></Review>
</template>

3.configure with menu
import AboutView from "@/views/AboutView.vue";
import HomeView from "@/views/HomeView.vue";
import ReviewView from "@/views/ReviewView.vue";
import { createRouter, createWebHistory } from "vue-router";

//it defines the menu (url) configuration against "View-page"
const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
    component: AboutView
  },
  {
    path: '/review',
    name: 'review',
    component: ReviewView
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: routes
})

export default router;
....................................................................

Final Code:

src/routes/index.js
import AboutView from "@/views/AboutView.vue";
import HomeView from "@/views/HomeView.vue";
import ReviewView from "@/views/ReviewView.vue";
import { createRouter, createWebHistory } from "vue-router";

//it defines the menu (url) configuration against "View-page"
const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
    component: AboutView
  },
  {
    path: '/review',
    name: 'review',
    component: ReviewView
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: routes
})

export default router;

src/App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
</script>
<template>
  <header>
    <h1>Site Header</h1>
    <!-- Menu Bar -->
    <nav>
      <ul>
        <li>
          <RouterLink to="/">Home</RouterLink>
        </li>
        <li>
          <RouterLink to="/about">About</RouterLink>
        </li>
        <li>
          <RouterLink to="/review">Review</RouterLink>
        </li>
      </ul>

    </nav>
  </header>
  <!-- Body section to display menu content -->
  <RouterView></RouterView>
  <footer>
    <p>Footer</p>
  </footer>
</template>

src/views/ReviewView.vue
<script setup>
import Review from '@/components/reviews/Review.vue'

</script>
<template>
    <Review></Review>
</template>

src/components/reivew/Review.vue
<script setup>
import { useCounterStore } from '@/stores/counter.js'
const counterStore = useCounterStore()
</script>
<template>
    <div>
        <h1>Review</h1>
        <h1>Like {{ counterStore.count }}</h1>
        <button @click="counterStore.count++">+</button>
    </div>
</template>
.................................................................................
								  router,pinia,api call
...............................................................................

stores/posts.js
import { defineStore } from "pinia";

export const usePostsStore = defineStore('posts', {
    state: () => {
        return {
            posts: [],
            error: null
        }
    },
    actions: {
        //async 
        async fetchPosts() {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts')
                const posts = await response.json()
                this.posts = posts
            }
            catch (err) {
                this.error = err
                console.log(err)
            }
        }
    },
    getters: {
        postList: state => state.posts
    }

})

src/views/PostsView.vue
<script setup>
import Posts from '@/components/posts/Posts.vue'
</script>
<template>
    <Posts></Posts>
</template>

src/components/posts/Posts.vue
<script setup>
import { onMounted } from 'vue'
import { usePostsStore } from '@/stores/posts.js'

const postsStore = usePostsStore()
onMounted(() => {
    postsStore.fetchPosts()
})
</script>
<template>
    <h1>Post App with Pinia-Router</h1>
    <div v-for="post in postsStore.postList">
        <h2>{{ post.title }}</h2>
        <p>{{ post.body }}</p>
    </div>
</template>

src/router/index.js
import AboutView from "@/views/AboutView.vue";
import HomeView from "@/views/HomeView.vue";
import PostView from "@/views/PostView.vue";
import ReviewView from "@/views/ReviewView.vue";

import { createRouter, createWebHistory } from "vue-router";

//it defines the menu (url) configuration against "View-page"
const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/about',
    name: 'about',
    component: AboutView
  },
  {
    path: '/review',
    name: 'review',
    component: ReviewView
  },
  {
    path: '/posts',
    name: 'posts',
    component: PostView
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: routes
})

export default router;

src/App.vue
<script setup>
import { RouterLink, RouterView } from 'vue-router'
</script>
<template>
  <header>
    <h1>Site Header</h1>
    <!-- Menu Bar -->
    <nav>
      <ul>
        <li>
          <RouterLink to="/">Home</RouterLink>
        </li>
        <li>
          <RouterLink to="/about">About</RouterLink>
        </li>
        <li>
          <RouterLink to="/review">Review</RouterLink>
        </li>
        <li>
          <RouterLink to="/posts">Posts</RouterLink>
        </li>
      </ul>

    </nav>
  </header>
  <!-- Body section to display menu content -->
  <RouterView></RouterView>
  <footer>
    <p>Footer</p>
  </footer>
</template>
.................................................................................
